{"page_id": "3", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "JDK", "page_content": "[TOC]\n\nJDK(Java Development Kit) 作为Java语言的软件开发工具包影响了一代又一代开发人员。\n\n我们使用JDK1.8作为开发SDK。\n\n# 下载地址\njava目标对于JDK的版本维护存在CPU（奇数）版本与PSU（偶数）版本。奇数版本为重要补丁，偶数版本为全部补丁。Oracle建议大多数用户应当选择 CPU 版本。\n[下载地址](https:\\/\\/www.oracle.com\\/technetwork\\/java\\/javase\\/downloads\\/jdk8-downloads-2133151.html)\n\n# 环境变量\n\n新建环境变量 JAVA_HOME：\n\n```\nJAVA_HOME={安装路径}\n```\n\n新增环境变量PATH（如果存在不需要新建）：\n\n```\nPATH=%JAVA_HOME%\\\\bin;%JAVA_HOME%\\\\jre\\\\bin;\n```\n\n\n\n# 确认安装\n\n终端中输入 java -version\n\n```\njava version \\\"xxx\\\"\nJava(TM) SE Runtime Environment (build xxx)\nJava HotSpot(TM) 64-Bit Server VM (build xxx, mixed mode)\n```", "s_number": "99", "addtime": "2019-10-15 14:21:19", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "4", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "Gradle", "page_content": "[TOC]\n# 介绍\nGradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。\n\n\n# 安装\n[下载地址](https:\\/\\/gradle.org\\/next-steps\\/?version=4.10.3&format=bin)\nBinary-only：仅仅是运行版本\nComplete： 包含源码和文档的版本\n\n下载后解压到目录即可\n\n# 环境变量配置\n\n新增环境变量：\n\nGRADLE_HOME: 安装路径\n\n示例如下，路径请自行修改\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-09-17\\/5d803de2aac34.png)\n\n# 私有仓库设置\n\n在gradle仓库目录下新建文件，默认在以下目录：\n\n```\n~\\/.gradle\\/init.gradle\n```\n\n**注意：如果自行修改过gradle仓库目录，则需要在相应目录建立。**\n\n文件内容如下：\n\n```\nallprojects {\n    repositories {\n        maven {\n         \\turl 'http:\\/\\/192.168.50.55:8081\\/nexus\\/content\\/groups\\/public\\/'\n\\t  \\t}\n  \\t}\n}\n```\n\n\n\n# 依赖刷新\n由于我们使用的是镜像仓库，经常更新框架代码是常有的事情，当仓库中的版本更新后，我们可以刷新仓库依赖来下载最新代码。\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-09-17\\/5d80398928a17.png)", "s_number": "99", "addtime": "2019-10-15 14:22:46", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "5", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "Maven", "page_content": "[TOC]\n# 介绍\n\nApache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\n\nMaven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。Maven曾是Jakarta项目的子项目，现为由Apache软件基金会主持的独立Apache项目。\n\n我们后台管理使用Maven进行构建。\n\n# 安装\n[下载地址](https:\\/\\/maven.apache.org\\/download.cgi)\n\n下载bin版本即可：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-09-17\\/5d803a5454a06.png)\n\n下载后解压即可。\n\n# 环境变量配置\n\n新增环境变量\n\nMAVEN_HOME: 安装路径\n\n如下，路径请自行修改：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-09-17\\/5d803d64db889.png)\n\n# 私有仓库设置\n\n在maven仓库目录下新建文件，默认在以下目录：\n\n```\n~\\/.m2\\/settings.xml\n```\n\n在profiles节点下增加如下内容：\n\n如果不存在profiles新建即可。\n\n```\n\\t<profile>\n        <id>whdx<\\/id>\n        <repositories>\n            <repository>\n                <id>central<\\/id>\n                <url>http:\\/\\/192.168.50.55:8081\\/nexus\\/content\\/groups\\/public\\/<\\/url>\n                <releases><enabled>true<\\/enabled><\\/releases>\n                <snapshots><enabled>true<\\/enabled><\\/snapshots>\n            <\\/repository>\n        <\\/repositories>\n    <\\/profile>\n```\n\n# 仓库选择\n\n打开后台管理项目，选择Profiles，如下图：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-09-17\\/5d803cb854c52.png)", "s_number": "99", "addtime": "2019-10-15 14:28:41", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "6", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "Git", "page_content": "[TOC]\n\nGit是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。\nGit 易于学习，体积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，可以低成本的创建本地分支，便捷的创建临时区域（stash）和多个工作流程等功能。\n# 学习资料\n关于git的学习，建议大家首先要理解其工作原理及思想，再去了解常用的命令。\n推荐几篇文章：\n[git原理入门](http:\\/\\/www.ruanyifeng.com\\/blog\\/2018\\/10\\/git-internals.html)\n[git常用的分支流程](http:\\/\\/www.ruanyifeng.com\\/blog\\/2015\\/12\\/git-workflow.html)\n\n# 安装\n[下载地址](https:\\/\\/www.git-scm.com\\/download\\/)\n下载后按提示安装即可\n\n# 密钥创建\n大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权。\nSSH 公钥默认储存在账户的主目录下的 ~\\/.ssh 目录，进入该目录查看是否存在 id_dsa和id_dsa.pub，如果不存在，我们需要生成一个，打开git bash，输入以下命令：\n\n```\nssh-keygen\n```\n\n我们会得到如下类似的反馈，一直回车即可：\n\n```\nGenerating public\\/private rsa key pair.\nEnter file in which to save the key (\\/Users\\/schacon\\/.ssh\\/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in \\/Users\\/schacon\\/.ssh\\/id_rsa.\nYour public key has been saved in \\/Users\\/schacon\\/.ssh\\/id_rsa.pub.\nThe key fingerprint is:\n43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local\n```\n\n完成后我们就可以查看id_dsa.pub文件的内容，并在需要的时候使用。\n\n# .gitconfig配置\n\n在.gitconfig中增加git提交时展示的用户名和邮箱：\n\n```\n[user]\n\\tname = 姓名英文全拼\n\\temail = 公司邮箱\n```\n\n\n# Git使用注意事项\n\n## 合并\n\n推荐合并时使用--no-ff，此命令会保留原分支合并轨迹（即便源分支已删除）。大体代码如下\n\n```\ngit checkout master\ngit checkout -b featrue\ngit add \ngit commit \ngit checkout master\ngit pull \ngit merge --no-ff featrue\ngit push\n```\n\n## 高版本修复低版本\n如果我们同时需要维护多个版本，那么必然会遇到在高版本修复一个bug后同步到低版本。\n此时我们应该使用--cherry-pick(采摘樱桃)命令，cherry-pick命令允许我们将某一次提交应用到其他分支。 大体代码如下：\n\n```\ngit checkout 2.0.0\ngit checkout -b fix2.0\ngit add\ngit commit\ngit push\ngit checkout 1.0.0\ngit cherry-pick <COMMIT-ID>\ngit push\n```", "s_number": "99", "addtime": "2019-10-15 14:29:29", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "7", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "SourceTree", "page_content": "[TOC]\n\nSourceTree是一个Git的图形化工具。它简化了我们与Git存储库交互的方式，使开发人员可以专注于编码（而不是在解决冲突）。它的功能远不止一个UI，可以查看官网了解更多。\n\n图形化工具的使用不是意味着放弃命令，相反地想要熟练的使用图形化工具仍然需要对git命令的了解。\n\n# 安装\n[下载地址](https:\\/\\/www.sourcetreeapp.com\\/)\n\n## 注册账号\n下载完成打开，进入初始化页面。选择Create One for Free在弹出的页面注册账号：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd377eb6fd86.png)\n\n## 登录\n\n注册账号并验证邮箱，完成后关闭页面。回到初始化页面，点击Bitbucket在弹出的页面进行登录：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd377f3e8d63.png)\n\n## 初始化配置\n\n登录成功点击下一步，进入配置页面，我们使用系统已经安装的Git，此处不需要勾选Mercurial，点击下一步：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd377f7ea304.png)\n\n## 密钥配置\n\n配置完成后，sourcetree会提示我们是否创建密钥，我们使用自己的密钥，这里选择否，进入主页面：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd377fe5bd18.png)\n\n在顶部工具栏中依次点击工具->选项。\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378037738e.png)\n\n选择一般选项卡，在ssh客户端的选项中，选择OpenSSH，如果此时已经安装并配置过git，则会自动填充ssh密钥的路径。\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd37809422fd.png)\n\n## no-ff\n我们需要开启提交时默认使用no-ff的形式，在git选项卡中，勾选：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd3780dd3527.png)\n\n## 语言\n默认sourcetree使用的是中文页面，由于某些命令在翻译成中文后难以理解，建议还是将界面修改为英文，修改后重启sourcetree即可：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378131be32.png)\n\n## 用户名邮箱修改\n在选项->一般选项卡中，修改用户名与邮箱为姓名全拼和公司邮箱。\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd37817b871e.png)\n\n## 冲突解决工具\n\n如果我们已经安装了svn，建议使用tortoiseMerge作为冲突合并工具。在options->diff中修改diff和merge工具：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd3781bac3c2.png)\n\n# 仓库导入\n## 远程仓库导入\n拿到git的ssh地址，如：\n\n```\ngit@git.bcbook.cn:whdx_ms\\/whdx-framework-project.git\n```\n\n选择clone选项卡，将地址填充，选择要clone到本地的路径，点击clone即可：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd37821d6dc4.png)\n\n## 本地存在的仓库\n\n如果本地已经存在git仓库（含有.git隐藏文件的目录），我们可以直接导入，使用sourcetree进行管理。\n选择Add选项卡，填充本地路径，点击Add即可：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378270a300.png)\n\n\n# 版本管理\n## 拉取\n在左侧remotes节点中可以看到远程全部的分支，双击即可拉取到本地，在左侧BRANCHES中展示本地的分支。\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd3782c2c61b.png)\n\n我们双击可以切换本地的分支，并且可以点击Pull拉取最新的推送：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378309c3d2.png)\n\n## 提交\n\n本地修改后，可以在Working Copy中查看修改，并且进行提交，默认情况下提交操作是提交到git的本地仓库，并不会推送到远端：\n\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd37835a7b9b.png)\n\n选择Stage暂存到将要提交的文件列表中：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd37839a2a95.png)\n\n输入本次提交的注释，点击commit即可。\n如果在下面勾选了Push，会同时推送到远端。\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd3789c6b04f.png)\n\n## 推送\n\n当我们进行commit操作后，本地分支与Push按钮上均会出现未推送到远端的提交数量。\n\n我们选择Push推送到远端：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378bb47653.png)\n在弹出的取消push tag选项，点击push按钮推送：\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-09\\/5cd378bde9aae.png)\n", "s_number": "99", "addtime": "2019-10-15 14:30:19", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "8", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "Intellij IDEA", "page_content": "[TOC]\n\nIntelliJ IDEA是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言。\n\n# 安装\n\n[下载地址](http:\\/\\/www.jetbrains.com\\/idea\\/download\\/)\n\n下载Ultimate最新版即可。\n\n# 破解\n[破解地址](http:\\/\\/idea.lanyus.com\\/)\n\n# 项目引入\n\n选择gradle方式引入\n\n![](https:\\/\\/www.showdoc.cc\\/server\\/api\\/common\\/visitfile\\/sign\\/c42fe37b0b2028305d0692293f4b1c4c?showdoc=.jpg)\n\n勾选自动刷新依赖，并且选择我们下载的高版本gradle作为构建工具（低版本对于snapshot支持很差）.\n![](https:\\/\\/www.showdoc.cc\\/server\\/api\\/common\\/visitfile\\/sign\\/8d700a8192df4b97a9fbf42462ff0ec4?showdoc=.jpg)\n\n点击finish打开项目等待gradle构建。\n\n# 插件安装\n## Lombok\nLombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的。\n\n1. 打开Intellij Idea,进入Settings->Plugins。\n2. 点击Browse Repositories。\n3. 在输入框中输入Lombok Plugin,安装即可\n\n安装后，配置开启。\n![](http:\\/\\/showdoc.bcbook.cn:4999\\/server\\/..\\/Public\\/Uploads\\/2019-05-29\\/5ceddc497a5d6.png)", "s_number": "99", "addtime": "2019-10-15 14:25:39", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "9", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "2", "page_title": "SpringBoot环境变量", "page_content": "在电脑的系统变量中添加环境变量：\n键：SPRING_PROFILES_ACTIVE\n值：local\n如果当前正在打开IDEA，需要关闭IDEA重新打开，以重新加载环境变量。", "s_number": "99", "addtime": "2019-10-15 14:32:38", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "30", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "4", "page_title": "业务架构", "page_content": "[TOC]\n\n本节将介绍我们目前的后端所涉及到的技术点及应用方式，以便快速熟悉开发流程。\n\n#1. 技术架构图\n\n\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-09/5d241122ce2fa.jpg)", "s_number": "99", "addtime": "2019-10-15 17:27:44", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "31", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "4", "page_title": "技术架构", "page_content": "[TOC]\n\n本节将介绍我们目前的后端所涉及到的技术点及应用方式，以便快速熟悉开发流程。\n\n#1. 技术架构图\n\n\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-09/5d241122ce2fa.jpg)", "s_number": "99", "addtime": "2019-10-15 17:28:52", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "32", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "4", "page_title": "SpringCloud", "page_content": "[TOC]\n\n# 1. 介绍\nSpring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态）。分布式系统的协调可以引入一种模式：样板模式，使用Spring Cloud开发人员可以快速站起来实现这些模式的服务和应用程序。它们适用于任何分布式环境，包括开发人员自己的笔记本电脑，裸机数据中心和Cloud Foundry等托管平台。\n\n\n# 2. 误区\n1. “SpringCloud是微服务”。SpringCloud是微服务的一种实现，而不是微服务本身，不要将SpringCloud作为微服务唯一的解决方案。相反，SpringCloud本身同样提供了每种组件的多样化实现。\n2. “SpringCloud是微服务的银弹”。SpringCloud虽然是微服务实现的全家桶，但它不是“银弹”，它只是提供了最基本的框架，当业务复杂度不断提高，对周边设施的基本功能要求不断提高后，Spring Cloud所提供的组件便难以支撑业务的需求。当然，SpringCloud提供了扩展接口，我们可以扩展自己想要的东西，然而个性化与风险总是并存的。\n3. “Spring Cloud对Java开发人员友好”。SpringCloud大部分的组件的确是由Java编写的，然而它官方也在不断的使用其他非java的框架来作为替代方案。\n\n\n# 3. 基本流程\n\n就目前而言，我们使用SpringCloud的基本流程如下：\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-26/5d130313b4383.png)\n\n\n#4. 部署顺序\n\n1. eureka\n2. config-server\n3. boot-admin\n4. hystrix\n5. api-gateway\n6. 业务项目", "s_number": "99", "addtime": "2019-10-15 17:29:08", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "33", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "4", "page_title": "Kubernetes", "page_content": "[TOC]\n\n本节我们主要针对kubernetes做一个简要的介绍，使开发人员了解我们的部署过程\n\n## Docker\n要介绍Kubernetes，我们首先要引出Docker。\nDocker是一个打包、分发和运行应用程序的平台。它允许将你的应用程序和应用程序所依赖的整个环境打包在一起。并且传输这个包到中央仓库。之后这个包可以分发并运行在任何docker的机器上。\n\nDocker主要包含了三个概念：\n\n1. 镜像：包含了应用程序、依赖的环境。\n2. 镜像仓库：镜像最终存放在镜像仓库中，以便共享。\n3. 容器：基于镜像创建。一个运行中的容器是一个运行在docker主机上的进程，但它和其它任何东西都是隔离的。这个进程的资源只能使用你预先分配给它的。\n\nDocker的使用流程：\n\n1. 开发者编写Dockerfile。并且构建镜像。\n2. 推送至镜像仓库。\n3. 生产机器拉取镜像仓库的镜像使用。\n\n## K8s\nKubernetes经常被称为“k8s”，由来：k+8个单词+s。\n\n## 为什么使用\n\n1. 大量的服务在部署时需要我们考虑需要多少资源、部署在哪台机器。维护成本不断增加。我们需要一些自动化的措施来解决。kubernetes提供了包括自动调度、配置、监管、故障处理等措施来解决这些问题。\n2.  开发、运维对系统管理的理解程度不同、关注点不同，导致在生产系统的维护产生的很大问题。为此我们希望的是开发、生产环境一致。\n3. 让开发和运维分别做自己擅长的事情：开发人员能够自己部署应用上线，无须运维；运维团队负责管理生产环境的硬件设备，只关心系统的安全、以及对开发人员优先级不高的东西，我们不希望运维去关注应用内的各种依赖关系，也不想运维去关心底层操作系统的改变会不会影响到应用程序。\n4. kubernetes对实际硬件做了一个抽象，将自身暴露成一个平台，用于部署和运行应用。它允许开发者自己配置和部署应用，而无须运维的帮助。让运维聚焦于保持底层基础设施运转正常的同时，不需要关注实际运行在平台上的应用。\n\n\n## 几个重要概念\n### Pod\nPod是一组并置的容器，代表了k8s中的基本构建模块，是k8s中的最小单元，用于管理docker容器。我们的应用都存放于docker中，docker通过pod创建并管理。\n\n### ReplicaSet\nRS被称为副本管理器，用于Pod的自动伸缩与故障处理。我们只需要告诉RS我们需要多少个服务，它便会自动寻找满足资源的服务器，并自动构建Pod。当Pod发生故障时，它会自动删除Pod并创建新的Pod。\n\n### Service\n对于微服务而言，pod通常需要请求集群内部的其他pod，或者针对来自外部的http请求做出响应。Service解决了这些问题。Service是集通信、负载、服务发现众多功能于一体的组件。\n\n### Deployment\n\n1. Deployment 是一种更高阶资源， 用于部署应用程序并以声明的方式升级应用， 而不是通过 ReplicationController 或 ReplicaSet 进行部署， 它们都被认为是更底层的概念。\n2. 当创建一个 Deployment 时， ReplicaSet 资源也会随之创建(最终会有更多的资 源被创建)。 在使用Deployment时，实际的pod 是由 Deployment 的 Replicaset 创建和管理的， 而不是由 Deployment 直接创建和管理的。\n3. 使用Deployment可以更容易地更新 应用程序，因为可以直接定义单个 Deployment资源所需达到的状态，并让Kubemetes处理中间的状态。\n4. 我们可以使用Deployment实现滚动式升级，这保证了无停机状态的应用更新。\n\n### ConfigMap\n1. 应用配置的关键在于能够在多个环境中区分配置边项，将配置从应用程序源码中分离，可频繁变更配置值 。 如果将 pod 定义描述看作是应用程序源代码，显然需 要将配置移 出 pod 定义 。 微服务架构下正是如此， 该架构定义了如何将多个个体组件组合成功能系统。\n2. Kubemetes 允许将配置选项分离到单独的资源对象 ConfigMap中， 本质上就是 一个键/值对映射，值可以是短字面量，也可以是完整的配置文件。\n3. 应用无须直接读取ConfigMap， 甚至根本不需要知道其是否存在。映射的内容通过环境变量或者卷文件的形式传递给容器，而并非直接传递给容器。\n\n## 常用组件关系图\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-25/5d117ab65cd12.png)\n\n", "s_number": "99", "addtime": "2019-10-15 17:28:19", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "10", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "基本配置", "page_content": "[TOC]\n\n# 依赖引用\n我们针对常用的组件基于SpringBoot进行了二次封装，形成了便于使用的组件库。\n在build.gradle中引入我们的bom（需要引入spring-boot-gradle插件）：\n\n```\nplugins {\n\tid 'org.springframework.boot' version '2.1.5.RELEASE'\n\tid 'java'\n}\n\napply plugin: 'io.spring.dependency-management'\n\ndependencyManagement {\n\timports {\n\t\tmavenBom \"com.whdx:whdx-framework-project:{lastVersion}-SNAPSHOT\"\n\t}\n\tresolutionStrategy {\n\t\tcacheChangingModulesFor 0, 'seconds'\n\t}\n}\n```\n\n引入我们需要的组件：\n\n```\ncompile('com.whdx:spring-boot-starter-web')\n```\n\n\n全部组件列表见基础组件一章中。\n\n# 配置引用\n组件库中内置了常用组件的公共配置，可以一键引入，免去复杂配置。\n\n在application.yml文件中引入：\n\n```\nspring:\n  profiles:\n    include:\n      - web\n      - mybatis\n```\n\n并且我们内置了大量app开头的配置，在引入组件的依赖后，输入“app.”即可查看。\n\n全部可引入的yaml及可用的配置见基础组件一章中。\n\n\n\n\n# Application类\n由于我们的组件库中会自动开启常用的注解，所以我们的Application类中的注解可简化为如下：\n\n```\n@SpringCloudApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n", "s_number": "99", "addtime": "2019-10-15 17:29:38", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "11", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "本地开发流程", "page_content": "大多数情况下，我们的开发是在本地进行的。\n由于微服务中的链路繁杂，服务众多等原因，本地打开所有的服务进行调试显然不可取，因此，我们需要一个便捷的开发环境。\n\n# 1. 环境变量\n本地需增加SPRING_PROFILES_ACTIVE 环境变量，详见开发环境搭建\n\n# 2.  application-local\n\n在本地新建application-local.yml文件，用于本地配置。\napplication-local.yml文件中，我们可以指定dev环境的eureka，连接至开发环境已经存在的注册中心。\n\n```\n# 设置本地启动的应用名称后缀，防止dev环境调用本服务时调用到。\nspring:\n  application:\n    name: paper-local\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://192.168.50.77:8761/eureka/\n```\n\n", "s_number": "99", "addtime": "2019-10-15 17:29:54", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "12", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "单元测试", "page_content": "[TOC]\n\n# 介绍\n测试是开发不可缺少的。\n在实际应用程序中，我们的编写的服务通常依赖其他系统（如：前端、微服务内部接口）。\n我们希望可以专注的测试某个功能，而不是涉及到整个系统。\n因此提供适当的单元测试是非常重要的。\n\n框架提供了BaseTest，以简化单元测试编写。\n我们需要在“/test/java/com/whdx/<模块名称>”包下新建单元测试类。\n\n# 约定\n\n1. 单元测试类所在的包必须与测试目标所在包一致，以便调用protected类型的方法。\n2. 普通增删改查逻辑无须单元测试，只需针对业务逻辑进行测试。\n\n# 本服务内的单元测试\n对于某个接口仅需要调用数据库而无须跨服务调用，我们只需要使用MockMvc模拟请求即可。\n\n\n```\n@SpringBootTest(classes = TestApplication.class)\npublic class ApiTest extends BaseTest {\n\n    /**\n     * get请求测试\n     */\n    @Test\n    public void testGet() throws Exception {\n        MockHttpServletRequestBuilder mockHttpServletRequestBuilder = MockMvcRequestBuilders\n                .get(\"/demo/testGet/{id}\", 1111);\n        mockHttpServletRequestBuilder.param(\"name\", \"张三\");\n        super.buildRequest(() -> mockHttpServletRequestBuilder);\n    }\n\n    /**\n     * post请求测试\n     */\n    @Test\n    public void testPost() throws Exception {\n        MockHttpServletRequestBuilder mockHttpServletRequestBuilder = MockMvcRequestBuilders\n                .post(\"/demo/testPost\");\n        Map<String,Object> requestMap = new HashMap<>();\n        requestMap.put(\"name\",\"张三\");\n        mockHttpServletRequestBuilder.content(JSON.toJSONString(requestMap));\n        super.buildRequest(() -> mockHttpServletRequestBuilder);\n    }\n}\n```\n\n# 跨服务的单元测试Mockito\n## 介绍\n由于我们大部分接口需要调用其他内部服务来完成业务，当我们多人协作开发时，我们只需要规定好响应的接口协议即可开始开发，无须关心他人服务。\n为此我们希望能够在不侵入代码的前提下，完成单元测试。\nSpring提供了mockito来解决上述问题。\nMockito框架可以创建和配置mock对象.它简化了具有外部依赖的单元测试，我们可以使用Mockito针对具有外部依赖的service层进行测试。\n一般来说Mockito的使用步骤:\n1. 将外部依赖通过Mockito进行模拟构造。\n2. 将构造后的依赖注入到引用它的类中。\n3. 为模拟的外部依赖，编写期望返回的结果。\n4. 正常调用需要进行单元测试的方法。\n\n## 快速使用\n下面的示例以paper项目中的“/student/wrongbook/getSubjectWrongCountList”接口作为示例：\n\n本单元测试代码路径：com.whdx.paper.student.StudentWrongBookTest中\n\n```\n@SpringBootTest(classes = WhdxPaperApplication.class)\npublic class StudentWrongBookTest extends BaseTest {\n    //标识该服务为mock生成，并注入到spring容器中。\n    @MockBean\n    private UserClassinfoStudentApi userClassinfoStudentApi;\n\n\n    @Test\n    public void testGetSubjectWrongCountList() throws Exception {\n        //模拟userClassinfoStudentApi.selectStudentSubjectList返回的数据\n        MessageBody<List<SysDictInfo>> mockMessage = new MessageBody<>();\n        List<SysDictInfo> list = new ArrayList<>();\n        SysDictInfo sysDictInfo = new SysDictInfo();\n        sysDictInfo.setValue(\"01111\");\n        sysDictInfo.setLabel(\"1110\");\n        list.add(sysDictInfo);\n        mockMessage.setRetData(list);\n        mockMessage.setRetCode(\"0000\");\n\n        //Mockito.when表示当执行某个方法时进行模拟\n        //Mockito.anyString()代表任意字符串类型的参数\n        //thenReturn表示期望模拟返回的结果\n        Mockito.when(userClassinfoStudentApi.selectStudentSubjectList(Mockito.anyString()))\n\t\t.thenReturn(mockMessage);\n\n        //使用MockMvc发起请求\n        MockHttpServletRequestBuilder mockHttpServletRequestBuilder = MockMvcRequestBuilders\n                .get(\"/student/wrongbook/getSubjectWrongCountList\");\n        mockHttpServletRequestBuilder.param(\"studentId\", \"10\");\n        super.buildRequest(() -> mockHttpServletRequestBuilder);\n    }\n\n}\n\n```\n\n运行单元测试，在StudentWrongBookController的getSubjectWrongCountList方法中打断点，监测UserClassinfoStudentApi的返回值是否为我们mock的。\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-05-14/5cda2e59f062a.png)", "s_number": "99", "addtime": "2019-10-15 17:30:35", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "13", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "项目发布流程", "page_content": "# 项目发布流程\n## 1.代码封版，代码合并，（服务端）、（前端）、（客户端）【开发】\n## 2.调整发布脚本【运维】\n## 3.准备批量导入数据【运维】\n## 4.生产环境停服务【运维】\n## 5.清空缓存，更新数据库脚本【开发】\n## 6.导入数据【运维】\n## 7.启动项目【运维】\n=========以上属于项目发布阶段=========\n## 8.停止定时任务【开发】\n## 9.配置系统\n- a.配置后台菜单和权限【开发】\n- b.配置栏目，栏目图片，资源相关内容【编辑】\n- c.配置注意事项，用户规范【产品】\n- d.配置banner，用户公告【运营】\n\n## 10.启动定时任务【开发】\n=========以上属于项目配置阶段========\n## 11.测试工作\n- a.功能测试【测试】【运营】【产品】\n- b.数据检查【编辑】\n- c.问题修复【开发】\n- d.项目二次发布【运维】\n\n## 12.测试完成，整理版本测试报告，APP打包【测试】\n=========以上属于项目测试阶段==============\n## 13.配置APP升级版本，推送PAD客户端【运营】\n=========以上属于新版本推送阶段=============\n\n# v2.3版本主要功能\n\n## 1.老师自主上传+在线编辑试卷\n- 需要产品同事配置上传须知，分学科，提供相关上传模板\n## 2.期末复习\n- a.需要编辑配置期末复习栏目图片，根据学科调整栏目\n- b.需要编辑配置期末复习章节目录，上传相关资源\n- c.配置地区专版试卷\n## 3.插屏闪屏增加页面内容展示\n## 4.H5注册功能\n- 提供给运营同事H5注册地址，测试易企秀功能\n## 5.作业测试布置流程修改【可布置给所有对象，名师指点可布置，显示老师要求等】\n## 6.注册反馈功能（找不到学校功能）\n## 7.多选和双选的展示\n## 8.护眼模式\n## 9.app联系客服，口语功能诗歌类居中展示，APP注册会员领取180天vip\n- 产品配置相关提示内容\n## 10.学校信息采集放开-河北限制\n## 11.whadmin后台相关功能（由编辑同事测试）\n\n", "s_number": "99", "addtime": "2019-10-15 17:30:52", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "14", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "开发环境代理转发", "page_content": "[TOC]\n\n# 1. 背景\n在SpringCloud架构下，开发过程中的联调成为痛点。\n\n一般情况下，开发人员需要运行多个或全部服务，或干扰其他环境才可正常进行联调，成本极高。\n\n我们希望找到一种简单、快速的方式来解决以下问题。\n\n## 1.1 仅希望启动正在开发的服务\n开发人员通常只希望启动当前正在开发的服务，但微服务存在众多链路，仅启动下游服务是无法通过从上游服务直接访问的。\n通常我们需要启动一个上游服务指向本地的下游服务或通过线上负载不断请求，通过一定频率落在本地服务。\n\n所以我们需要一个能够在上游服务直接请求到本地服务的方法，减少不必要的等待。\n\n## 1.2 希望在联调阶段断点\n当开发进入前后端联调时，如开发环境存在问题，开发人员通常希望与前端进行断点调试以快速找到问题。\n但我们的服务不仅仅是针对某一人提供的，此时如果他人请求我们所断点的服务，即会出现问题。\n\n所以我们需要一个能够针对某个人所单独提供特定服务（即本地服务）的方法，以便进行点对点调试。\n\n\n\n\n# 2. 快速使用\n为了解决上述问题，我们研发了[微服务代理中心](http://whdx-ms-dev-boot-admin.bcbook.cn/proxy)。\n\n\n1. 该代理可以将某个客户端ip发出的请求转发到所配置的目标机器。\n2. 配置成功后，该服务的一切请求均将被代理，无论其处于链路的哪个阶段。\n3. 点对点代理，不会影响他人访问。\n\n\n\n## 2.1 添加代理\n进入页面后，点击左上方添加代理。在弹出的页面中录入相关数据。\n代理添加成功后，本地客户端正常请求接口即可。\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-21/5d0c83a1b6ac4.png)\n\n客户端ip：这里的客户端指的是最初的访问者，即打开浏览器或打开某个应用的用户所使用的终端ip。\n目标ip：要访问的机器的ip地址，即某个后端开发人员的机器ip。\n目标端口：要访问的机器端口，即某个后端开发人员所开启的应用端口。端口号为数字，如：8080\n代理服务：要代理的开发环境服务名称，如：paper、common、user。具体某个服务经过链路最终所到达的服务名称需询问相关后端人员。\n\n全部服务名可以从此地址查看：[eureka](http://192.168.50.77:8761/)。进入后，application即服务名\n\n\n添加相同ip、服务名的代理，即会覆盖已经存在的代理。\n\n**请注意：服务名为开发环境的服务名称，而非本地所启动的local服务，代理服务应填写paper而非paper-local。**\n\n## 2.2 筛选代理\n在页面右上方可以进行筛选。\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-21/5d0c85120b805.png)\n\n\n## 2.3 清空本机代理\n\n点击按钮可以清空本机ip所设置的全部代理，联调结束后，请及时清空代理，以免为后续调试造成影响。\n\n## 2.4 清空全部代理\n\n点击按钮可以清空全部代理，请谨慎使用。\n\n## 2.5 删除单个代理\n\n在表格后方操作栏中可删除单个代理。\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-21/5d0c8596914ff.png)\n\n# 3. 原理\n基本思想：对于代理而言，基本思路就是拦截请求方所要请求的地址，转发到我们希望其到达的目的地。\n\n对于本服务而言，我们将客户端所配置的代理均存放在redis中，并且在请求发出前，比对当前请求是否存在于redis内，如果存在，重写其地址为redis中所配置的地址。\n\n基于目前的框架，代理转发服务需要代理的组件有两种。\n一种是spring cloud gateway所配置的上游服务的路由，如webapi、padapi等。\n另外一种是服务间的通讯OpenFeign，如paper服务调用common服务。\n\n我们分别对用于实现代理的两种组件的原理进行介绍。\n\n## 3.1 SpringCloudGateway\n对于Gateway而言，我们只需要为其添加一个[全局过滤器](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html#_global_filters)，拦截请求后修改url地址即可。\n\n由于我们的gateway是注册进eureka的，所以默认情况下，会存在一个LoadBalancerClientFilter。\n\nLoadBalancerClientFilter从名字就可以看出，它的作用是针对客户端的请求进行负载，它会将以\"lb:\"开头的请求（由路由配置的）从eureka中通过策略拿出一个可用的远端服务，并且转发请求至改服务。这与我们要做的代理转发相同。\n\n而我们只需要在其过滤器执行前，将url地址改变，从而不经过其过滤器，转而从正常的http请求即可。\n\n关键代码如下：\n\n```\n@Slf4j\npublic class ProxyForwardRequestFilter implements GlobalFilter, Ordered {\n    public static final String CLIENT_PROXY_FORWARD_KEY = \"feign-client-proxy-forward\";\n\t//小于LoadBalancerClientFilter过滤器的排序，会先一步执行\n    public static final int PROXY_FORWARD_REQUEST_FILTER = 10099;\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);\n        String schemePrefix = exchange.getAttribute(GATEWAY_SCHEME_PREFIX_ATTR);\n\n        if (url == null || (!\"lb\".equals(url.getScheme()) && !\"lb\".equals(schemePrefix))) {\n            return chain.filter(exchange);\n        }\n\n        //保留原始url\n        addOriginalRequestUrl(exchange, url);\n\n        String clientIp = NetworkUtil.getIp(exchange.getRequest());\n        //要请求的服务名称\n        String clientName = url.getHost();\n\n        //获取代理\n        FeignClientProxyForward proxyForward = getProxyForward(clientIp, clientName);\n\n        //如果目标请求未代理，走原请求\n        if (proxyForward == null) {\n            //不做任何操作\n            return chain.filter(exchange);\n        }\n        //如果被代理，修改代理的ip，重新构建URI\n        URI newUrl = replaceHostName(url.toString(), clientName, proxyForward.getTargetIp() + \":\" + proxyForward.getTargetPort());\n\n        exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, newUrl);\n\n        return chain.filter(exchange);\n    }\n}\n```\n\n\n## 3.2 OpenFeign\n针对于OpenFeign的拦截会复杂一些，接下来的所涉及到的内容会冗长且繁杂，希望大家可以多一些耐心。\n先来看一张OpenFeign在SpringCloud使用过程中基本的类图关系：\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-06-24/5d1071d9b6f5b.png)\n\n\n简单描述下上述流程：\n1. Spring启动时，注册Client，Client为Feign的具体调用类。由于我们使用的eureka，故会注册LoadBalancerFeignClient。\n2. 当我们加入@EnableFeignClients注解后，Spring启动时会执行FeignClientsRegistrar，扫描包下的@FeignClient注解，创建FeignClientFactoryBean。FeignClientFactoryBean为Feign的工厂生成类，会生成多个Feign的实现类注入到Spring中。\n3. 由于我们使用Hystrix，故会生成HystrixFeign。该类引用并扩展了ReflectiveFeign，ReflectiveFeign为继承Feign的具体实现类。\n4. HystrixFeign中创建HystrixInvocationHandler，HystrixInvocationHandler为代理方法，会在执行真实方法前执行所附加的方法，该类会附加hystrix的command策略。由于我们使用的sleuth，故默认注入的是SleuthHystrixConcurrencyStrategy策略，该策略包装了请求，并传递了trace，以供整个链路使用。\n5. ReflectiveFeign同时会创建一个SynchronousMethodHandler代理类，该类会feign的拦截器（如果存在）。\n6. 最终当我们调用FeignClient所注解的接口中的方法时，会首先调用SynchronousMethodHandler执行拦截器，接着调用HystrixInvocationHandler执行包装请求，最终通过LoadBalancerFeignClient发出请求。\n\n\n### 3.2.1 如何扩展\n\n当我们理解整个过程中，我们得到以下几个信息：\n\n1. 在hystrix包装过程中，会创建线程，从而与当前请求到controller所在的线程隔离，如果要传输当前请求线程中的数据，需要在包装类创建的线程中传入，sleuth就是这样做的。\n2. 拦截器是在hystrix包装前之前执行的，并且两者在同一线程。\n3. 我们需要在发出请求前改变url，也就是LoadBalancerFeignClient内。\n\n\n### 3.2.2 关键代码\n\n#### 3.2.2.1 传递请求方ip\n\nHystrixConcurrencyStrategy为我们提供了扩展口，它允许我们自己实现一个策略，以允许在传输过程中传递参数，sleuth已经为我们实现了，因此我们可以仿照其代码进行修改：\n\n\n```\n@Slf4j\npublic class TransferHeaderHystrixConcurrencyStrategy extends HystrixConcurrencyStrategy {\n    private HystrixConcurrencyStrategy delegate;\n    public TransferHeaderHystrixConcurrencyStrategy() {\n        try {\n\t\t\t//hystrix通过HystrixPlugins注册各种信息。\n            this.delegate = HystrixPlugins.getInstance().getConcurrencyStrategy();\n            if (this.delegate instanceof TransferHeaderHystrixConcurrencyStrategy) {\n                return;\n            }\n            HystrixCommandExecutionHook commandExecutionHook =\n                    HystrixPlugins.getInstance().getCommandExecutionHook();\n            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance().getEventNotifier();\n            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance().getMetricsPublisher();\n            HystrixPropertiesStrategy propertiesStrategy =\n                    HystrixPlugins.getInstance().getPropertiesStrategy();\n            this.logCurrentStateOfHystrixPlugins(eventNotifier, metricsPublisher, propertiesStrategy);\n            HystrixPlugins.reset();\n            HystrixPlugins.getInstance().registerConcurrencyStrategy(this);\n            HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook);\n            HystrixPlugins.getInstance().registerEventNotifier(eventNotifier);\n            HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher);\n            HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy);\n        } catch (Exception e) {\n            log.error(\"Failed to register Sleuth Hystrix Concurrency Strategy\", e);\n        }\n    }\n@Override\n    public <T> Callable<T> wrapCallable(Callable<T> callable) {\n\n        if (callable instanceof TransferCallable) {\n            return callable;\n        }\n        Callable<T> wrappedCallable = this.delegate != null\n                ? this.delegate.wrapCallable(callable) : callable;\n        if (wrappedCallable instanceof TransferCallable) {\n            return wrappedCallable;\n        }\n\t\t//将当前请求信息拿到，放入包装类所在线程中\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        return new TransferCallable<>(wrappedCallable, requestAttributes);\n    }\n\n\n    static class TransferCallable<T> implements Callable<T> {\n        private final Callable<T> delegate;\n\n        private final RequestAttributes requestAttributes;\n\n\n        public TransferCallable(Callable<T> delegate, RequestAttributes requestAttributes) {\n            this.requestAttributes = requestAttributes;\n            this.delegate = delegate;\n        }\n\n        @Override\n        public T call() throws Exception {\n            try {\n\t\t\t //将当前请求信息拿到，放入包装类所在线程中\n                RequestContextHolder.setRequestAttributes(requestAttributes);\n                return delegate.call();\n            } finally {\n                RequestContextHolder.resetRequestAttributes();\n            }\n        }\n    }\n}\n```\n\n#### 3.2.2.2 在拦截器的header中放入真实ip\n实现拦截器，将包装类所在线程中的信息，拿出放入header中传递。\n\n```\n/**\n * @author zhangbowen\n * @since 2019-06-20\n * 转发ip\n */\npublic class TransferClientIpRequestInterceptor implements RequestInterceptor {\n    @Override\n    public void apply(RequestTemplate template) {\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder\n                .getRequestAttributes();\n        if (attributes == null) {\n            return;\n        }\n        HttpServletRequest request = attributes.getRequest();\n        //放入ip\n        template.header(NetworkUtil.HEADER_X_FORWARDED_FOR, NetworkUtil.getIp(request));\n    }\n}\n```\n\n#### 3.2.2.3 实现client，重写url\n\n我们需要实现自己的client，以便由redis中读取所配置的代理信息，并且重写url。\n\n```\npublic class ProxyForwardLoadBalancerFeignClient implements Client {\n\t @Override\n    public Response execute(Request request, Request.Options options) throws IOException {\n        //获取当前请求方的ip。\n        //根据ip获取该ip设置的代理列表，判断是否存在当前clientName。\n        //如果存在，重写url，转向访问代理。\n        try {\n            URI asUri = URI.create(request.url());\n            String clientName = asUri.getHost();\n            //判断该次请求的目标服务是否代理\n            FeignClientProxyForward proxyForward = getProxyForward(request, clientName);\n            //如果目标请求未代理，走原请求\n            if (proxyForward == null) {\n                //走原方法\n                return original(request, options);\n            }\n            //如果被代理，修改代理的ip，重新构建URI\n            URI uriWithoutHost = replaceHostName(request.url(), clientName, proxyForward.getTargetIp() + \":\" + proxyForward.getTargetPort());\n            FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest(\n                    this.delegate, request, uriWithoutHost);\n            IClientConfig requestConfig = getClientConfig(options, clientName);\n            return lbClient(clientName)\n                    .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();\n        } catch (ClientException e) {\n            IOException io = findIOException(e);\n            if (io != null) {\n                throw io;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n}\n```", "s_number": "99", "addtime": "2019-10-15 17:31:09", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "15", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "微服务拆分原则", "page_content": "[TOC]\n\n# 1. 介绍\n\n在微服务架构下，我们设计、开发往往丢不下以往单体应用的思想，由于目前我们大部分情况都是数据驱动开发，故我们从数据库的拆分入手，来梳理下微服务架构下，数据库及项目的拆分。\n\n目前平台系统中涉及到最多的业务便是对于试卷的操作，我们以该实体为例进行分析。\n\n\n# 2. 以往的设计思路\n\n对于试卷的基础实体，往往是由业务最初的需求而决定的，假如我们以如下信息作为试卷的基础信息。\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-19/5d313a75f27c4.png)\n\n当我们的业务不断发展，我们会不断增加paper中标的字段，我们总是思考将某张表做成通用，最终会增加很多类型去区分。这种方式在简单业务下没有问题，但当业务复杂后，表中的冗余字段会不断增加。如下：\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-19/5d3139079629f.png)\n\n\n我们发现：\n\n1. 某些字段只针对某个业务建立，而对于其他业务并没有任何用处。\n2. 某些字段多个业务共用，不同情况下存储的值不同，引起歧义。\n\n我们需要针对业务进行设计、拆分表结构。\n\n# 3. 微服务设计思路\n\n既然要针对业务进行拆分，首先我们要分析出业务的主要功能以及扩展业务。\n\n对于目前来讲，布置作业、测试、组卷、阅卷，都是针对试卷进行操作的，故试卷就是我们的主要业务功能。\n\n对于主要业务功能，我们需要的是内聚、不受污染。我们需要的是最初的paper。\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-19/5d313a7fbbf38.png)\n\n对于子业务，如布置作业，我们需要建立自己的业务表，并且与paper建立关系。\n\npaper主要业务与子业务的表完全可以分别建立独立的数据库中，如下图：\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-19/5d313c84c8b49.png)\n\n这样，我们可以在exam表中加入exam业务所需的字段，在exam_paper表中，加入exam所需paper表作出修改的字段，两个系统之间相互独立、互不影响。\n\n并且，我们可以针对paper服务做一系列的优化、升级，如增加paper查询缓存，提高paper的入库效率，增加针对paper调用的统计分析等周边功能。\n\n此时，paper便成为了基础服务，而不是一个与业务冗余在一起大而全的服务。", "s_number": "99", "addtime": "2019-10-15 17:31:28", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "16", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "5", "page_title": "部署、发布", "page_content": "微服务项目在为我们带来好处的同时也为我们带来诸多不便，其中最为明显的便是应用的数量众多而导致部署和管理的复杂性。想象我们某个项目组存在10个微服务项目，一般来说我们需要dev、test、stage、prod四种环境，那便需要部署10*4=40个项目，这对于运维来说，无疑是恐怖的。\n\n我们希望开发人员与运维人员分别做自己擅长的事情。开发人员能够自己部署应用，无须运维，开发人员无须关心底层操作系统的改变是否会影响应用的正常运行；运维团队负责管理环境的硬件设备、系统的安全、以及对开发人员优先级不高的东西，运维不用理解应用内的各种依赖关系。\n\n为此，我们将GitLab、Jenkins、K8s三种不同职责的平台进行结合，实现了一套基于Git仓库的，集打包、构建、发布于一体的自动化平台。\n\n请移步[此处](http://cicd.bcbook.cn/)查看如何发布、部署。", "s_number": "99", "addtime": "2019-10-15 17:31:41", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "34", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "组件版本说明", "page_content": "[TOC]\n# v1.1.2\n\n组件名称|引入依赖|引入配置\n----|----|----\nbaidu云服务|spring-boot-starter-baidu|\ncc视频服务|spring-boot-starter-ccvideo|\nelasticsearch|spring-boot-starter-elasticsearch|elasticsearch\nkafka消息|spring-boot-starter-kafka|kafka\nmongo|spring-boot-starter-mongo|mongo\nmpush|spring-boot-starter-mpush|\nmybatis|spring-boot-starter-mybatis|mybatis<br>disable-db\npoi工具|spring-boot-starter-poi|\nredis|spring-boot-starter-redis|redis\nswagger|spring-boot-starter-swagger|swagger\n接口项目基础包|spring-boot-starter-web|web\nxxl-job客户端|spring-boot-starter-xxl-job|xxl-job\nxxl-job调度中心|spring-boot-starter-xxl-job-admin|\nspring boot admin监控|spring-cloud-starter-boot-admin|bootstrap/boot-admin\n微服务客户端基础包|spring-cloud-starter-client|bootstrap/cloud-client\n配置中心|spring-cloud-starter-config-server|\n注册中心|spring-cloud-starter-eureka-server|eureka-server\n网关|spring-cloud-starter-gateway|api-gateway<br>bootstrap/api-gateway\n熔断监控|spring-cloud-starter-turbine|\n\n# v1.1.1\n\n组件名称|引入依赖|引入配置\n----|----|----\namqp消息|spring-boot-starter-amqp|rabbit\nbaidu云服务|spring-boot-starter-baidu|\ncc视频服务|spring-boot-starter-ccvideo|\nelasticsearch|spring-boot-starter-elasticsearch|elasticsearch\nkafka消息|spring-boot-starter-kafka|kafka\nmongo|spring-boot-starter-mongo|mongo\nmpush|spring-boot-starter-mpush|\nmybatis|spring-boot-starter-mybatis|mybatis<br>disable-db\npoi工具|spring-boot-starter-poi|\nredis|spring-boot-starter-redis|redis\nswagger|spring-boot-starter-swagger|swagger\n接口项目基础包|spring-boot-starter-web|web\nxxl-job客户端|spring-boot-starter-xxl-job|xxl-job\nxxl-job调度中心|spring-boot-starter-xxl-job-admin|\nspring boot admin监控|spring-cloud-starter-boot-admin|bootstrap/boot-admin\n微服务客户端基础包|spring-cloud-starter-client|bootstrap/cloud-client\n配置中心|spring-cloud-starter-config-server|\n注册中心|spring-cloud-starter-eureka-server|eureka-server\n网关|spring-cloud-starter-gateway|api-gateway<br>bootstrap/api-gateway\n熔断监控|spring-cloud-starter-turbine|\n\n\n# v1.1.0\n\n组件名称|引入依赖|引入配置\n----|----|----\nbaidu云服务|spring-boot-starter-baidu|\ncc视频服务|spring-boot-starter-ccvideo|\nelasticsearch|spring-boot-starter-elasticsearch|elasticsearch\nkafka消息|spring-boot-starter-kafka|kafka\nmongo|spring-boot-starter-mongo|mongo\nmpush|spring-boot-starter-mpush|\nmybatis|spring-boot-starter-mybatis|mybatis<br>disable-db\npoi工具|spring-boot-starter-poi|\nredis|spring-boot-starter-redis|redis\nswagger|spring-boot-starter-swagger|swagger\n接口项目基础包|spring-boot-starter-web|web\nspring boot admin监控|spring-cloud-starter-boot-admin|bootstrap/boot-admin\n微服务客户端基础包|spring-cloud-starter-client|bootstrap/cloud-client\n配置中心|spring-cloud-starter-config-server|\n注册中心|spring-cloud-starter-eureka-server|eureka-server\n网关|spring-cloud-starter-gateway|api-gateway<br>bootstrap/api-gateway\n熔断监控|spring-cloud-starter-turbine|", "s_number": "99", "addtime": "2019-10-15 17:32:02", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "35", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "组件的开发", "page_content": "[TOC]\n# 项目地址\n\n```\nhttp://git.bcbook.cn/whdx_ms/whdx-framework-project\n```\n\n# 项目结构\nspring-boot-starter-xxx\nwhdx-xxx\nxxx为具体组件模块名称，whdx-xxx为主要源码包，spring-boot-starter-xxx包将源码类注入到Spring中。\n\n# Spring组件\nSpring组件的开发其实是将Java的工具类由Spring管理，或者基于Spring的扩展点进行扩展现有Spring组件的过程。\n\n\n## @Component注解\n最基本的就是使用Spring默认提供的一系列注解如：@Component、@Service，将某个类注入到Spring中，来方便其他类的使用。并且提供@PostConstruct与@PreDestroy来管理组件的创建与销毁。\n\n## BeanPostProcessor\nBeanPostProcessor是Spring提供的针对于Bean启动时的扩展点，我们可以针对某个Bean在启动前或启动后针对bean或其内部做一些处理。\nSpring中@Autowried也有对应的Processor：AutowiredAnnotationBeanPostProcessor。\n\n我们可以利用BeanPostProcessor与自定义注解，扫描某个SpringBean中包含自定义注解的引用，并为其动态创建对象。\n\n\n```\n@Service\npublic class Test{\n\t@CustomAnno\n\tprivate TestProcessor testProcessor;\n}\n```\n\n在Processor中我们可以也同时实现BeanFactoryAware获取Factory，将我们动态创建出来的对象注入到Spring容器中。\n\n## ImportBeanDefinitionRegistrar\nImportBeanDefinitionRegistrar是Spring提供的在扫描Bean之前的扩展点，允许我们向Spring提供Bean的定义描述，以便于Bean被Spring扫描以注入到容器内。\n\n一般情况下我们需要与ClassPathBeanDefinitionScanner进行配合使用。我们可以继承该类，实现自己的注册逻辑。\nClassPathBeanDefinitionScanner是通过一些列的前置条件，来扫描出满足条件的类并放入注册表中等待注入。\n\n我们可以创建自定义注解，使用ClassPathBeanDefinitionScanner进行扫描注入到Spring中。\n我们也可以重写其doScan方法，为某个bean的定义设置Bean工厂，生产接口的动态代理类，以注入到Spring中。\n\n常见的实现：@MapperScanner、@EnableFeignClients\n\n\n\n# SpringBoot组件开发示例\nSpring Boot的作用是为我们提供了自动配置来更方便的管理Spring组件的初始化。\nwhdx-xxx为源码包\nspring-boot-starter-xxx控制源组件注入到Spring中。\n\n以较为简单的Redis监听广播组件为例，该组件扫描自定义注解来监听注解所标识的topic发来的消息。\n## 自定义注解\n新建自定义注解@RedisListener。\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface RedisListener {\n    /**\n     * 定义要监听的channel数组，可为pattern模式\n     *\n     * @return 监听的channel数组\n     */\n    String[] value() default {};\n}\n```\n\n## RedisListenerProcessor\nProcessor用于将扫描到的注解所标识的topic创建一个MessageListenerAdapter，放入RedisMessageListenerContainer中，MessageListenerAdapter允许我们传输某个类及某个类的方法名来进行监听。\n\n```\npublic class RedisListenerProcessor implements BeanPostProcessor {\n    private final RedisMessageListenerContainer redisMessageListenerContainer;\n\n    public RedisListenerProcessor(RedisMessageListenerContainer redisMessageListenerContainer) {\n        this.redisMessageListenerContainer = redisMessageListenerContainer;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {\n        return o;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, final String beanName) {\n        Class<?> targetClass = AopUtils.getTargetClass(bean);\n        Map<Method, RedisListener> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n                (MethodIntrospector.MetadataLookup<RedisListener>) method -> AnnotatedElementUtils.findMergedAnnotation(method, RedisListener.class));\n        annotatedMethods.forEach((method, v) -> {\n            MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(bean, method.getName());\n            messageListenerAdapter.afterPropertiesSet();\n            String[] channels = v.value();\n            for (String channel : channels) {\n                redisMessageListenerContainer.addMessageListener(messageListenerAdapter, channel.contains(\"*\") ? new PatternTopic(channel) : new ChannelTopic(channel));\n            }\n        });\n        return bean;\n    }\n}\n```\n\n## RedisProperties\n创建Redis的配置文件，根据配置来控制组件的初始化。\n\n```\n@ConfigurationProperties(prefix = \"app.redis\")\n@Data\npublic class RedisProperties {\n    /**\n     * 是否开启 true/false\n     */\n    private boolean enabled;\n}\n\n```\n\n## RedisAutoConfiguration自动配置\n\n在RedisAutoConfiguration中通过配置文件中的的配置控制是否开启该组件。\n\n```\n@Configuration\n@ConditionalOnProperty(prefix = \"app.redis\", name = \"enabled\", havingValue = \"true\")\npublic class RedisAutoConfiguration {\n   @Bean\n    @ConditionalOnMissingBean\n    public static RedisListenerProcessor redisListenerProcessor(RedisMessageListenerContainer redisMessageListenerContainer) {\n        return new RedisListenerProcessor(redisMessageListenerContainer);\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public RedisMessageListenerContainer redisContainer(RedisConnectionFactory redisConnectionFactory) {\n        RedisMessageListenerContainer container\n                = new RedisMessageListenerContainer();\n        container.setConnectionFactory(redisConnectionFactory);\n        return container;\n    }\n}\n```\n\n## spring.factories\n\nspring.factories将RedisAutoConfiguration暴露给Spring的扫描器，扫描我们的自定义配置。\n在spring-boot-starter-xxx中resources目录下，新建/META-INF/spring.factories，指定RedisAutoConfiguration全类名。\n\n```\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.whdx.framework.redis.spring.boot.autoconfigure.RedisAutoConfiguration\n```", "s_number": "99", "addtime": "2019-10-15 17:32:14", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "36", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Mybatis", "page_content": "[TOC]\n\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n本节只介绍基本使用，满足日常开发需要，更多进阶使用请查看官网。\n\n[官网地址](https://mp.baomidou.com/guide/)\n\n#1. 引入\n\ngradle：\n\n```\ncompile('com.whdx:spring-boot-starter-mybatis')\n```\n\n基本配置：\n\n```\nspring:\n  application:\n    name: paper\n  profiles:\n    include:\n    - web\n    - mybatis\napp:\n  datasource:\n    host: mysql-dev\n    name: whadmin\n    username: root\n    password: 123456\n```\n\n#2. 创建实体类\n\n```\n@Data\n@TableName(\"tb_user\")\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String isStudent;\n}\n```\n\n#3. 创建Mapper接口\n可以使用mybatis的@Mapper注解，或者直接继承BaseMapper即可，此处演示继承：\n\n```\npublic interface UserMapper extends BaseMapper<User> {\n}\n```\n\nBaseMapper实现了诸多常用的方法，可以自行查看，我们无须编写xml文件即可使用内置的方法。\n\n\n#4. 创建Service\n\n\n建立Service，继承ServiceImpl类。\n\n```\n@Service\npublic class UserService extends ServiceImpl<UserMapper, User> {\n}\n```\n\nServiceImpl针对BaseMapper进行了优化，如getOne()不会抛出异常，batch时自动分段。\n无须注入\n\n#5. 增删改查\n\n##5.1 查询\n\n```\n    /**\n     * 根据主键id查询详情\n     *\n     * @param id 用户id\n     * @return 用户详情\n     */\n    public User queryById(Long id) {\n        return super.getById(id);\n    }\n\t /**\n     * 根据条件查询详情\n     *\n     * @param user 请求参数\n     * @return 用户详情\n     */\n    public User query(User user) {\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        if (!StringUtils.isEmpty(user.getName())) {\n            queryWrapper.eq(User::getName, user.getName());\n        }\n        return super.getOne(queryWrapper);\n    }\n\t /**\n     * 根据条件查询列表\n     *\n     * @param user 请求参数\n     * @return 用户详情\n     */\n    public List<User> list(User user) {\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        if (!StringUtils.isEmpty(user.getName())) {\n            queryWrapper.eq(User::getName, user.getName());\n        }\n        return super.list(queryWrapper);\n    }\n\n```\n\n更多的使用方式，可以直接使用this/super查看。\n\n##5.2 新增\n\n```\n    /**\n     * 添加用户\n     *\n     * @param user 实体\n     * @return ResponseEntity\n     */\n    public ResponseEntity add(User user) {\n        super.save(user);\n        return new ResponseEntity(HttpStatus.CREATED);\n    }\n```\n\n##5.3 更新\n\n```\n\t /**\n     * 修改用户\n     *\n     * @param user 实体\n     * @return ResponseEntity\n     */\n    public ResponseEntity update(User user) {\n        super.updateById(user);\n        return new ResponseEntity(HttpStatus.CREATED);\n    }\n```\n##5.4 删除\n\n```\n\t /**\n     * 删除用户\n     *\n     * @param id 主键id\n     * @return ResponseEntity\n     */\n    public ResponseEntity delete(Long id) {\n        super.removeById(id);\n        return new ResponseEntity(HttpStatus.NO_CONTENT);\n    }\n```\n\n#6. 分页\n##6.1 基本使用\n\n针对我们的业务，框架扩展了mybatis-plus原有的分页实体，我们需要使用的是框架所在包名的Page类。\n对于controller层用于接收请求的实体，建议继承PageRequest类。\n\n```\n@Data\npublic class UserRequest extends PageRequest{\n\tprivate String name;\n}\n```\n\n```\n    public PageResponse<User> page(UserRequest user) {\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        if (!StringUtils.isEmpty(user.getName())) {\n            queryWrapper.eq(User::getName, user.getName());\n        }\n\t\tIPage<User> pageResult = super.baseMapper.selectPage(PageRequest.mybatis(user),queryWrapper);\n         return PageResponse.mybatis(pageResult);\n    }\n```\n\n##6.2 直接构造分页请求\n\n在某些场景下，我们可以直接构造分页请求实体。\n\n```\n    public PageResponse<User> page(User user) {\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        if (!StringUtils.isEmpty(user.getName())) {\n            queryWrapper.eq(User::getName, user.getName());\n        }\n\t\tIPage<User> pageResult = super.baseMapper.selectPage(PageRequest.mybatis(1,10),queryWrapper);\n        return PageResponse.mybatis(pageResult);\n    }\n```\n\n##6.3 在xml中的分页\n对于在Mapper中自定义的方法，我们需要传入Page对象，并且保证在第一位。\n\nBaseMapper:\n```\n//可以继承或者不继承BaseMapper，不继承时，需要使用@Mapper注解\npublic interface UserMapper extends BaseMapper<User>{\n    /**\n     * <p>\n     * 查询 : 根据state状态查询用户列表，分页显示\n     * 注意!!: 如果入参是有多个,需要加注解指定参数名才能在xml中取值\n     * </p>\n     *\n     * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象)\n     * @param state 状态\n     * @return 分页对象\n     */\n    IPage<User> selectPageVo(IPage page, @Param(\"state\") Integer state);\n}\n```\n\nxml文件:\n```\n<select id=\"selectPageVo\" resultType=\"com.baomidou.cloud.entity.UserVo\">\n    SELECT id,name FROM user WHERE state=#{state}\n</select>\n```\n\nservice调用：\n\n```\n\npublic PageResponse<User> selectUserPage(UserRequest request, Integer state) {\n\tPageRequest pageRequest = request.mybatis();\n\tIPage<User> pageResult = userMapper.selectPageVo(pageRequest, state);\n    return  PageResponse.mybatis(pageResult);\n}\n```\n\n##6.4 取消分页\n\n设置pageSize为-1时，即可取消分页。同时不会查询count。\n\n```\nPageRequest.mybatis(0,0);//会将0修正为-1。\nPageRequest.mybatis(0,-1);\n```\n\n##6.5 取消count\n有些情况下，分页插件对于复杂的sql无法生成最优的count语句，我们需要编写自己的count。\n\n```\n//当 total 为非 0 时(默认为 0),分页插件不会进行 count 查询\npageRequest.setTotal(1);\n```\n\n##6.6 获取前N条\n\n如果不使用分页，我们可以使用last为现有sql，增加limit语句，只返回n条数据。\n\n```\n queryWrapper.last(\"limit 70\");\n```\n\n", "s_number": "99", "addtime": "2019-10-15 17:32:26", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "37", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Redis", "page_content": "[TOC]\n\n# 1. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-redis')\n```\n\n# 2. 配置\n\n```\nspring:\n  profiles:\n    include:\n      - redis\napp:\n  redis:\n    host: redis-dev\n    password: 123\n```\n\n# 3. 缓存\n框架提供了三种使用缓存的方式，根据喜好可自行选择。\n注意：三种方式不可混用。\n\n## 3.1 CacheFacade\nCacheFacade用于暴露简单的key/value形式的缓存操作，由yml配置文件控制缓存中间件的使用。\n在CacheFacade的高级抽象中缓存的value值使用fastjson进行序列化，对于任意的缓存中间件，实际存储的是json字符串。\n\n### 3.1.1 设置缓存\n\n```\n//设置key为userlist，value为list，时间为10秒的缓存。\nList<User> list = new ArrayList<>();\nCacheFacade.set(\"userlist\",list,10);\n```\n\n\n### 3.1.2 获取缓存\n\n```\nList<User> list = CacheFacade.get(\"userlist\",new TypeReference<List<User>>(){});\n```\n\n### 3.1.3 删除缓存\n\n```\nCacheFacade.delete(\"userlist\")\n```\n\n### 3.1.4 key是否存在\n\n\n```\nCacheFacade.existKey(\"userlist\")\n```\n\n\n\n## 3.2 RedisTemplate\n如果我们希望使用redisTemplate进行操作redis，以实现更加复杂的数据结构。\n框架提供了RedisHelper来获取template，可以传入泛型类，来支持集合类型的泛型结构。\n\n```\nRedisHelper.template(T.class);\n```\n\n\n## 3.3 @Cacheable注解\n\n```\n\t@Cacheable(cacheNames = \"cacheName\", key = \"'keyName\")\n    public List<TestBean> testCache() {\n```\n\n请注意，返回值如果为集合类型，需要指明泛型。\n\n\n其中key如果不指定，默认为当前方法所在类的全类名+方法名+参数\n\ncacheName可以使用#分隔符设置该缓存的缓存时间，单位为秒，如下设置失效时间为100秒：\n\n\n```\n\t@Cacheable(cacheNames = \"cacheName#100\")\n    public List<TestBean> testCache() {\n```\n\n\n# 4. 发布订阅的扩展\n\nPubSub 模式，是 Publish/Subscribe 的缩写，意为“发布/订阅”模式。\n\n订阅者（Sub）通过SUBSCRIBE命令向redis 服务订阅频道（channel），当发布者通过PUBLISH 命令向channel发布命令时，订阅该频道的客户端都会受到此消息。（请不要将发布/订阅与点对点混淆）\n\n> JMS规范目前支持两种消息模型：点对点（point to point， queue）和发布/订阅（publish/subscribe，topic）。其中点对点模式中，一个Queue可以有多个消费者注册等待消费，但消息由一个消费者从Queue中取出后其它消费者将无法消费，即一个消息仅可由一个消费者消费，多个消费者注册。而发布/订阅模式发布到topic的消息，所有订阅者均会消费。\n\n点对点实现了一个可靠的负载均衡，而发布订阅则是消息的拷贝。\n\nspring-data-redis所提供的发布/订阅使用方式复杂切繁琐，而且需要手动配置在类中，无法做到解耦。故我们优化了其配置使用方式。\n\n> redis的发布/订阅不同于kafka，由于kafka针对发布/订阅做了大量工作，使得kafka的发布/订阅在分布式系统下仍然可以保证不重复、有序等特点。而redis并没有这些功能，因此redis的发布/订阅只是类似与普通的观察者模式（通知）。如果您希望使用一个可靠的消息系统，建议还是引入专业的消息中间件，redis建议还是作为缓存系统。\n\n\n### 4.1 订阅消息\n\n新建监听类注入到Spring中，在方法上方添加@RedisListener注解，以此来监听channel。\n\n```\n@Component\npublic class ChannelTestListener {\n    @RedisListener(\"channel1\")\n    public void onMessage(String s) {\n        System.out.println(s);\n    }\n}\n\n```\n\n### 4.2 发布消息\n\n\n```\nredisTemplate.convertAndSend(\"channel1\",\"hello\");\n```", "s_number": "99", "addtime": "2019-10-15 17:33:16", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "38", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "分页", "page_content": "由于项目中会包含多种分页，如mybatis、mongo、elasticsearch。所以针对分页统一封装了PageRequest和PageResponse的转换工具。\n\n# 1. 构建分页请求\n\n```\nPageRequest.mybatis();//mybatis分页请求\nPageRequest.data();//spring-data分页请求\n```\nps：建议在controller层接收参数的bean，直接继承PageRequest。\n\n\n# 2. 构建分页响应\n\n```\n//mybatis分页响应\nPageResponse<T> response = PageResponse.mybatis(IPage<T>);\n//spring-data分页响应\nPageResponse<T> response = PageResponse.data(Page<T>);\n```\n\n如果我们需要引入更多分页插件，在两个类中增加即可。", "s_number": "99", "addtime": "2019-10-15 17:33:28", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "39", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Elasticsearch", "page_content": "[TOC]\n\n\n#1. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-elasticsearch')\n```\n\n#2. 配置\n\n```\nspring:\n  profiles:\n    include:\n    - elasticsearch\n\napp:\n  elasticsearch:\n    host: es-dev\n    name: Dev-Cluster\n```\n\n#3. 新建实体\n\n```\n//type与indexName建议一致，或直接使用_doc（es在新版本中已废弃单index多type的形式）。\n@Data\n@Document(indexName = \"user\", type = \"user\")\npublic class User {\n    @Id\n    private String id;\n\t//可以设置不分词，防止在直接比对中由于标点符号等特殊字符导致无法匹配。\n    @Field(type = FieldType.String, index = FieldIndex.not_analyzed)\n    private String customerId;\n}\n```\n\n@Document注解会自动创建索引，在某些场景下可以指定createIndex关闭。\n\n#4. 新建Repository\n\n```\npublic interface UserRepository extends ElasticsearchRepository<User, String> {\n}\n\n```\n\nRepository提供了基本的增删改查。\n\n\n#5. 操作\n\n\n```\n@Service\n@Slf4j\n@AllArgsConstructor\npublic class UserService {\n    private UserRepository userRepository;\n    private ElasticsearchTemplate elasticsearchTemplate;\n\n    public User getById(String userId) {\n        return userRepository.findOne(userId);\n    }\n\tpublic PageResponse page() {\n        NativeSearchQueryBuilder nativeSearchQueryBuilder = new NativeSearchQueryBuilder();\n        nativeSearchQueryBuilder.withFilter(QueryBuilders.termQuery(\"id\",\"aaa\"));\n        nativeSearchQueryBuilder.withPageable(PageRequest.data(1,10));\n        Page page = customerRepository.search(nativeSearchQueryBuilder.build());\n        return PageResponse.data(page);\n    }\n}\n```\n\n一些复杂的语句可以使用elasticsearchTemplate进行操作。\n\n\n\n#6. 获取ESClient\n\n也可以使用es本身的JavaClient进行操作。注入Client即获得org.elasticsearch.client包下的Client客户端。\n\n```\n    @Autowired\n    private Client client;\n```", "s_number": "99", "addtime": "2019-10-15 17:33:45", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "40", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "SpringCloudClient", "page_content": "[TOC]\n\n#1. 介绍\n初始化了spring cloud客户端所需要的基本配置及依赖。\n它默认引入了常用的微服务客户端所需的依赖关系，如下：\n\n```\n<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-feign</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-sleuth</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n```\n\n#2. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-cloud-client')\n```\n\n#3. 配置\n\n**注意：cloud的配置需要在bootstrap.yml文件中引入。**\n\n```\nspring:\n  profiles:\n    include:\n    - cloud-client\n```\n", "s_number": "99", "addtime": "2019-10-15 17:33:59", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "41", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Mongo", "page_content": "[TOC]\n\n# 1. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-web')\ncompile('com.whdx:spring-boot-starter-mongo')\n```\n\n#2. 配置\n\n```\nspring:\n  profiles:\n    include:\n    - mongo\napp:\n  mongo:\n    host: mongo-dev\n    name: whadmin\n    username: whadmin\n    password: whadmin123\n```\n\n#3. 简单使用\n\n##3.1 实体类\n\n```\n\n@Entity\n@Document\nclass User {\n\t@Id\n \tprivate Long id;\n\t...\n}\n```\n\n##3.2 继承接口\n```\ninterface UserRepository extends MongoRepository<User, Long> {\n}\n```\n\n也可以使用SpringData的查询语法来进行查询。\n\n```\ninterface UserRepository extends MongoRepository<User, Long> {\n  List<User> findByLastnameOrderByFirstnameDesc(String lastname)\n}\n\n```\n\n##3.3 分页\n\n```\npublic class UserService{\n\t@Autowried\n\tprivate UserRepository repository;\n    public PageResponse<User> page() {\n        Page<User> users = repository.findAll(PageRequest.data(1,10));\n        return PageResponse.data(users);\n    }\n}\n\n```\n\n#4. MongoTemplate\n也可以使用mongoTemplate操作。\n\n```\n@Autowired\nprivate MongoTemplate mongoTemplate;\n```\n\n", "s_number": "99", "addtime": "2019-10-15 17:34:13", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "42", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "响应消息体", "page_content": "[TOC]\n\n# 1. MessageBody基本结构\n接口响应消息体我们统一使用MessageBody进行封装。\n\n```\n /**\n     * 响应代码\n     */\n    @ApiModelProperty(value = \"响应代码\", required = true)\n    private String retCode;\n    /**\n     * 响应消息\n     */\n    @ApiModelProperty(value = \"响应消息\", required = true)\n    private String retMsg;\n    /**\n     * 响应数据\n     */\n    @ApiModelProperty(value = \"响应数据\")\n    private T retData;\n```\n\n#2. BaseCode结构\n其中，响应代码及消息使用枚举定义，需实现BaseCode接口，如下：\n\n```\npublic enum EnumSystemRetCode implements BaseCode {\n    SUCCESS(\"0000\", \"成功！\");\n\tEnumSystemRetCode(String retCode, String retMsg) {\n        this.retCode = retCode;\n        this.retMsg = retMsg;\n    }\n\n    private String retCode;\n    private String retMsg;\n\tpublic String getRetCode() {\n        return retCode;\n    }\n\n    public void setRetCode(String retCode) {\n        this.retCode = retCode;\n    }\n\n    public String getRetMsg() {\n        return retMsg;\n    }\n\n    public void setRetMsg(String retMsg) {\n        this.retMsg = retMsg;\n    }\n}\n```\n\n# 3. MessageBody便捷使用\n在接口使用时，我们提供了一系列针对于MessageBody的简易方法。\n\n## 3.1 成功请求存在消息体\n```\n EnumSystemRetCode.SUCCESS\n .messageBody(photoActivityService.pushQuestion(photoActivityPushQuestionRequest));\n```\n## 3.2 成功请求无消息体\n\n```\nEnumSystemRetCode.SUCCESS.empty();\n```\n\n## 3.3 错误请求抛出异常\n\n对于错误请求，对于不同业务需要新建实现BaseCode类的新的枚举类，此后便可以使用如下方法抛出异常。\n抛出异常后，全局异常拦截会自动组装成MessageBody消息体返回给请求方。\n\n```\n EnumRequestRetCode.VERIFY_FAIL.throwRESTfullException();\n```\n", "s_number": "99", "addtime": "2019-10-15 17:34:25", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "43", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "请求消息体", "page_content": "对于请求参数，当数量大于超过1时，必须建立bean。\n正常情况下，每个请求必须建立相应的请求与响应实体。\n对于参数验证，我们使用Spring中的@Validated注解完成。非不得已情况下，请不要使用if进行参数检验。\n\n#1. 实体中加入注解\n\n使用validator框架提供的各种注解，来验证参数有效性。本示例使用@NotEmpty。\n\n```\n@ApiModel(value = \"截图推题\", description = \"老师端推送题目\")\n@Data\npublic class PhotoActivityPushQuestionRequest {\n    @NotEmpty\n    @ApiModelProperty(value = \"互动类型（01选择题、10判断题、11简答题）\", required = true)\n    private String activityType;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"bucketName（上传获取）\", required = true)\n    private String bucketName;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"objectKey（上传获取）\", required = true)\n    private String objectKey;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"设备id\", required = true)\n    private String uuid;\n\n    private String userId;\n}\n```\n\n#2. Controller中验证\n\n在controller的参数中加入@Validated，开启验证。全局异常拦截会拦截验证抛出的异常，自动组装为MessageBody返回。\n\n```\n    /**\n     * 推题\n     *\n     * @param photoActivityPushQuestionRequest\n     * @return\n     */\n    @PostMapping\n    @ApiOperation(value = \"截图互动-推题\")\n    public MessageBody pushQuestion(@RequestBody @Validated PhotoActivityPushQuestionRequest photoActivityPushQuestionRequest) {\n        photoActivityPushQuestionRequest.setUserId(commonGetUserTeacherSo(photoActivityPushQuestionRequest.getUuid()).getId());\n        return photoActivityApi.pushQuestion(photoActivityPushQuestionRequest);\n    }\n```", "s_number": "99", "addtime": "2019-10-15 17:34:39", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "44", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Swagger", "page_content": "#1. 使用\n我们使用swagger生成接口文档。在编写接口时，我们需要在对外暴露的接口中，加入swagger的api描述注解。\n\n我们需要引入依赖：\n\n```\n    compile('com.whdx:spring-boot-starter-swagger')\n```\n\n\n# 2. 实体示例\n对于请求与返回，我们都需要新建实体来满足参数需要。如下为请求实体示例：\n\n```\n@ApiModel(value = \"截图推题\", description = \"老师端推送题目\")\n@Data\npublic class PhotoActivityPushQuestionRequest {\n    @NotEmpty\n    @ApiModelProperty(value = \"互动类型（01选择题、10判断题、11简答题）\", required = true)\n    private String activityType;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"bucketName（上传获取）\", required = true)\n    private String bucketName;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"objectKey（上传获取）\", required = true)\n    private String objectKey;\n\n    @NotEmpty\n    @ApiModelProperty(value = \"设备id\", required = true)\n    private String uuid;\n\n    private String userId;\n}\n```\n\n# 3. Controller示例\n\n\n```\n@Api(tags = \"teacher educate\")\n@RequestMapping(\"/teacher/educate/photoActivity\")\n@RestController\npublic class PhotoActivityController extends BaseController {\n    @Autowired\n    private PhotoActivityApi photoActivityApi;\n\n\n    /**\n     * 推题\n     *\n     * @param photoActivityPushQuestionRequest\n     * @return\n     */\n    @PostMapping\n    @ApiOperation(value = \"截图互动-推题\")\n    public MessageBody pushQuestion(@RequestBody @Validated PhotoActivityPushQuestionRequest photoActivityPushQuestionRequest) {\n        photoActivityPushQuestionRequest.setUserId(commonGetUserTeacherSo(photoActivityPushQuestionRequest.getUuid()).getId());\n        return photoActivityApi.pushQuestion(photoActivityPushQuestionRequest);\n    }\n}\n```", "s_number": "99", "addtime": "2019-10-15 17:35:11", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "45", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "日志", "page_content": "我们使用lombok提供的注解进行日志输出。\n\n# 1. 使用\n\n```\n@Slf4j\npublic class Test{\n\tpublic void test(){\n\t\tString param = \"1\";\n\t\t log.info(\"参数：{}\",param);\n\t}\n}\n```\n\n# 2. 注意事项\n\n1. 需要开启lombok插件，请移步开发环境搭建一节查看。\n2. 输出时，如存在变量，请时候{}进行格式化，不要使用string 拼接的形式。如上示例中所写。", "s_number": "99", "addtime": "2019-10-15 17:35:28", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "46", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "OpenFeign微服务调用", "page_content": "我们使用OpenFeign进行微服务间的通信。本节将介绍基本的使用过程，请遵循基本的编码规范。\n由于我们使用的是Spring官方扩展的OpenFeign版本，故整个开发过程中，我们使用Spring注解而非Feign注解。\n\n# 1. 创建Client\n\n```\n@FeignClient(\"test\")\npublic interface TestApi {\n}\n```\n\n1. 使用@FeignClient进行注释接口类，OpenFeign会自动生成Feign代理放入Spring容器中。\n2. 当注解的url存在时，为请求外网接口，当仅为value时，请求注册中心中存在的服务。\n3. 我们可以使用path来标明当前服务的前缀路由：\n```\n@FeignClient(value= \"test\",path=\"/prefix/router\")\npublic interface TestApi {\n}\n```\n\n# 2. 远程方法定义\n\n\n```\n @GetMapping(\"/test\")\n MessageBody test();\n```\n\n1. 请使用MessageBody作为返回值，无须手动抛出异常，全局异常拦截做这件事。\n2. 可以使用SpringBoot中提供的 @PostMapping、@GetMapping、@PutMapping、@DeleteMapping，请根据语义自行选择。\n\n# 3. 传参\n\n此处我们仅介绍场中的传参方式。\n\n## 3.1 QueryParam\n\nQueryParam展现形式为：\n\n```\nhttp://www.baidu.com?search=a\n```\n\n当我们使用此种方式时，如参数超过1个，请建立相关bean。\n\n以下为单个参数示例：\n\n```\n @GetMapping(\"/test\")\n MessageBody test(@RequestParam(\"param1\") String param1);\n```\n\n请注意：@RequestParam中需指明value值\n\n以下为多参数Bean形式示例：\n\n```\n@GetMapping(value = \"/test\")\nMessageBody test(@SpringQueryMap TestRequest request);\n```\n\n## 3.2 PathParam\n\nPathParam展现形式为：\n\n```\nhttp://www.baidu.com/{searchName}\n```\n\n示例：\n\n```\n @GetMapping(\"/test/{id}\")\n MessageBody test(@PathVariable(\"id\") String id);\n```\n\n请注意：@PathVariable中需指明value值\n\n## 3.3 RequestBody\n\nRequestBody请求方式一般来说需要将content-type设置为application/json，并且将要发出的参数转为json字符串，放入http body中传出，与上述两种方式不同的是，它们是基于uri的显式参数，而此种方式是基于body stream的，传输过程中无法直接查看其内容。\n\n示例：\n\n```\n    @PostMapping(value = \"/test\")\n    MessageBody test(@RequestBody Test request);\n```\n\n", "s_number": "99", "addtime": "2019-10-15 17:35:43", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "47", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Web365", "page_content": "[TOC]\n\n# 1. 配置\n\n```\napp:\n  web365:\n    wordPreview:http://ow365.cn/?i=12949&n=3&furl=  #web365  word预览参数\n\tpptPreview: http://ow365.cn/?i=12949&furl=   #web365  ppt预览参数\n\timagePathPreview: http://ow365.cn/?i=12949&info=1&furl=  #word365 图片预览地址\n```\n\n# 2. 使用\n\n在需要使用web365参数的位置，引入Web365Properties类，直接get 获取相应的参数即可。\n\n```\n    @Autowired\n    private Web365Properties web365Properties;\n```\n说明：目前仅仅是对 web365中ppt，word，image 在线预览地址等进行了封装，并未封装其他方法。\n\n", "s_number": "99", "addtime": "2019-10-15 17:35:55", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "48", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "MathType", "page_content": "[TOC]\n\n# 1. 配置\n\n首先需要配置公式转化服务器的路径地址，该地址提供图片转化公式方法。\n```\napp:\n  math:\n    serviceUrl: http://192.168.50.51/api/MathConvert\n```\n# 2. 使用\n\n在需要公式转化的类中 注入MathTypeService类即可。\n```\n@Autowired\n\tprivate MathTypeService mathTypeService;\n```\n其中 MathTypeService 提供了wmf图片转 mathMl 以及wmf 图片转base64的方法。\n\n可以参考微服务wordService中的作业测试上传解析公式方法，其中用到了wmf2mathMLBase64 方法。\n```\npublic String[] wmf2mathMLBase64(String[] wmfUrls) {\n\t\tlogger.debug(\"需要转换的公式图片：{}条,{}\", wmfUrls.length, wmfUrls);\n\t\tString[] mathMLs = wmf2mathML(wmfUrls);\n\t\tString[] encodedStrings = new String[mathMLs.length];\n\t\tfor(int i = 0; i < mathMLs.length; i++) {\n\t\t\tString mathML = mathMLs[i];\n\t\t\tif(StringUtils.isBlank(mathML)) {\n\t\t\t\tencodedStrings[i] = \"\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmathML = mathML.replaceAll(\"<annotation(.|\\\\n|\\\\r)*?</annotation>\", \"\");\n\t\t\tmathML = mathML.replaceAll(\"<!-- MathType.*-->\", \"\");\n\t\t\tmathML = mathML.replaceAll(\"<math.*>\", \"<math>\");\n\t\t\tmathML = mathML.trim();\n\t\t\tmathML = mathML.replaceAll(\"^([\\\\n\\r])?$\", \"\");\n\n\t\t\tlogger.trace(\"mathML: {}\", mathML);\n\n\t\t\tString encodeStr = Base64Utils.encodeToString(mathML.getBytes(Charsets.UTF_8));\n\t\t\tencodedStrings[i] = encodeStr;\n\t\t}\n\t\treturn encodedStrings;\n\t}\n```\n其中引用的 wmf2mathML方法代码为：\n```\n\tpublic String[] wmf2mathML(String[] wmfUrls) {\n\t\tif(wmfUrls == null || wmfUrls.length == 0) {\n\t\t\treturn new String[0];\n\t\t}\n\t\tString[] mathMLs = new String[wmfUrls.length];\n\t\tJSONObject reqJson = new JSONObject();\n\t\treqJson.put(\"ImageUrls\", wmfUrls);\n\t\ttry {\n\t\t\tString respText = postWithBody(mathTypeProperties.getServiceUrl(), reqJson.toJSONString());\n\t\t\tJSONObject respJson = JSONObject.parseObject(respText);\n\t\t\tInteger statusCode = respJson.getInteger(\"statusCode\");\n\t\t\tif(statusCode == 1) {\n\t\t\t\tJSONArray body = respJson.getJSONArray(\"body\");\n\t\t\t\tif(body != null) {\n\t\t\t\t\tfor(int i = 0; i < wmfUrls.length; i++) {\n\t\t\t\t\t\tString equation = body.getString(i);\n\t\t\t\t\t\tmathMLs[i] = equation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(HttpException e) {\n\t\t\tlogger.warn(\"公式转换接口请求失败\");\n\t\t}\n\t\treturn mathMLs;\n\t}\n```\n在使用过程中直接调用MathTypeService 中的公式转化即可将图片列表转化为公式列表。\n\n\n\n\n\n\n\n", "s_number": "99", "addtime": "2019-10-15 17:36:07", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "49", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "百度上传", "page_content": "我们使用百度BOS上传文件，客户端使用百度CDN请求资源。\n\n# 1. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-baidu')\n```\n\n# 2. 配置\n\n以下配置需要根据环境改具体修改。\n\n```\napp:\n  baidu:\n    bucket:\n      user: test-whdx-user # 百度后台所建立的bucket名称，目前只有user和admin\n      admin: test-whdx-admin #百度后台所建立的bucket名称，目前只有user和admin\n    bos:\n      endpoint: bj.bcebos.com # bos上传域名\n    cdn:\n      endpoint: cdn.bcebos.com # cdn域名\n    access-key-id: 7a6c172cd498487fa8c0843b7edd73ca # appId\n    secret-access-key: 7714cab50e854847b5b9d2518ec3640b # secret\n```\n\n\n# 3. 使用\n\n获取下载地址：\n\n```\n\t@Autowired\n\tprivate BaiduService baiduService;\n\tString downloadUrl = baiduService.getDownloadUrl(\"bucketName\", \"objectKey\", -1);\n```\n\n\n上传：\n\n```\n\t@Autowired\n\tprivate BaiduService baiduService;\n\t baiduService.getDownloadUrl(\"bucketName\", \"objectKey\", stream);\n```\n\n更多方法请查看BaiduService", "s_number": "99", "addtime": "2019-10-15 17:36:20", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "50", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "Kafka", "page_content": "[TOC]\n\n# 1. 基本介绍\nKafka是一个分布式流平台，它包含三个主要功能：\n1. 发布和订阅消息。\n2. 以容错的方式存储消息。\n3. 可以处理流。\n\n消息中间件的概念：消息中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。\n\n理解：消息中间件是用来解决系统之间传输大量数据时阻塞的问题。消息中间件提供了系统之间传输的媒介，用于持久化消息及对消息分发的负载。\n\n\n基本组成：\n\n1. producer：生产者，生产消息。\n2. consumer：消费者，消费消息。\n3. topic：类别/主题，生产消息时的分类，消费者消费对应类型的消息。相当于生产者将消息放入队列中，消费者从指定队列获取消息。消费者可以订阅多个主题。\n4. broker：中间商/代理。生产者生产的消息保存在这里。相当于存储媒介。消费者从broker拉取消息。\n\n# 2. Group（分组）和Partition（分区）\n首先要明确的一点，分组与分区是针对于读取消息的消费者而言的，与生产者无关。由于kafka消息的特殊性，其日志存储在硬盘中，故消费端可以重复消费。\n\n所以消费端引入了消费者组的概念来实现消息模型的队列和发布订阅模式，即消费端指定相同分组后，某个消息针对该分组只会被分发给该组中的消费者一次。\n\n而分区是用于并行消费的主要手段，每个topic在创建时，会生成N个分区（可配置），分区会存在于不同的节点服务器上。相同分组下的消费者，可以同时消费消息，即同时从不同的分区中拉取消息。相同分区下的消费是顺序执行的。\n\n在真实的物理磁盘存储中，分区的表现形式如下：\n\n```\ntestTopic-0\t\ttestTopic-1\t\ttestTopic-2\t\ttestTopic-3\n```\n\n在分区的下级目录，存储着真实的消息：\n\n```\n00000000000000000000.index\t\t00000000000000000000.log\t\t00000000000000000000.timeindex\n```\n\nps: 每条消息是由key、value、timestamp组成\n\n\n最终我们会得出以下结论，对于一条消息而言：\n\n1. 同一分组下的不同分区只会被消费一次，顺序无法保证，但可以并行消费。\n2. 同一分组下的同一分区会被消费一次，并且可以保证顺序执行。\n3. 不同分组下的消息会被重复消费。\n\n# 3. 快速使用\n\ngradle 引入：\n\n```\n\tcompile('com.whdx:spring-boot-starter-kafka')\n```\n\napplication.yml 配置：\n\n```\nspring:\n  profiles:\n    include: # 引入所需默认配置\n    - kafka\napp:\n  kafka:\n    host: kafka-dev\n```\n\n生产者发送消息：\n\n```\npublic class Test{\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\tpublic void test(){\n\t\t // 生产者发送的消息内容会自动序列化为json\n\t\t // 一般情况下，我们无须关心分组与分区\n\t\t kafkaTemplate.send(\"testTopic\", JSON.toJSONString(testService.selectList()));\n\t}\n}\n\n```\n\n消费者接收消息：\n\n```\npublic class Test{\n\t//一般情况下，我们无须指定分区或分组\n    @KafkaListener(topics = \"testTopic\")\n    public void test(String list){\n\t   List<T> list = JSON.parseArray(list,T.class);\n        System.out.println(list);\n    }\n}\n```\n\n# 4. 参数验证\n\n我们可以使用Spring注解@Validated 在消费端进行参数验证\n\n```\n    @KafkaListener(topics = \"validation-test\")\n    public void validationTest(@Validated Test test) {\n        System.out.println(\"验证测试：\");\n        System.out.println(test);\n    }\n```\n\n\n# 5. 死信\n\n我们可以使用以下配置开启死信模式：\n\n```\napp:\n  kafka:\n    error:\n      dead-letter: true\n```\n\n开启后，当我们的消费者抛出异常后，我们可以使用死信消费者进行监听异常消息，做后续处理：\n\n死信topic格式为：original-topic.DLT\n\n```\n/**\n     * 抛出异常\n     * @param userModel\n     */\n    @KafkaListener(topics = \"error-test\")\n    public void errorTest(String  json) {\n        System.out.println(\"错误验证：\");\n        System.out.println(userModel);\n        throw new RuntimeException(\"1\");\n    }\n\n    /**\n     * 死信监听\n     *\n     *     KafkaHeaders.DLT_EXCEPTION_FQCN - 异常类名称\n     *     KafkaHeaders.DLT_EXCEPTION_STACKTRACE -  异常堆栈跟踪。\n     *     KafkaHeaders.DLT_EXCEPTION_MESSAGE -异常消息。\n     *     KafkaHeaders.DLT_ORIGINAL_TOPIC - 原始主题。\n     *     KafkaHeaders.DLT_ORIGINAL_PARTITION 原始分区。\n     *     KafkaHeaders.DLT_ORIGINAL_OFFSET - 原始偏移量。\n     *     KafkaHeaders.DLT_ORIGINAL_TIMESTAMP - 原始时间戳。\n     *     KafkaHeaders.DLT_ORIGINAL_TIMESTAMP_TYPE -  原始时间戳类型。\n     *\n     * @param userModel\n     */\n    @KafkaListener(topics = \"error-test.DLT\")\n    public void errorTestDLT(String json,@Header(KafkaHeaders.DLT_EXCEPTION_STACKTRACE) String stack) {\n        System.out.println(\"死信消息：\");\n        System.out.println(userModel);\n    }\n```\n\n# 6. 回复型消息\n\n回复型消息创建时复杂，并且因为我们使用kafka只为了异步解耦，故一般情况下不建议使用：\n\n\n生产者：\n\n```\n\n    /**\n     * 发送消息后等待消费者回复\n     *\n     * @return\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    @GetMapping(\"/send\")\n    public String testSend() throws ExecutionException, InterruptedException {\n        UserModel userModel = new UserModel();\n        userModel.setId(\"测试id\");\n        userModel.setName(\"测试姓名\");\n        ProducerRecord<Object, Object> record = new ProducerRecord<>(\"reply-send-topic\", userModel);\n        RequestReplyFuture<Object, Object, Object> replyFuture = replyingKafkaTemplate.sendAndReceive(record);\n        SendResult<Object, Object> sendResult = replyFuture.getSendFuture().get();\n        System.out.println(\"Sent ok: \" + sendResult.getRecordMetadata());\n        ConsumerRecord<Object, Object> consumerRecord = replyFuture.get();\n        System.out.println(\"Return value: \" + consumerRecord.value());\n        return \"success\";\n    }\n```\n\n消费者：\n\n```\n    @KafkaListener(topics = \"reply-send-topic\")\n    @SendTo\n    public UserModel listen(String json) {\n        System.out.println(json);\n        UserModel success = new UserModel();\n        success.setName(\"成功的\");\n        return success;\n    }\n```", "s_number": "99", "addtime": "2019-10-15 17:36:36", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "51", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "日期参数", "page_content": "# 1. 请求参数\n1. 对于日期参数，由于系统遗留问题，目前我们建议使用LocalDatetime或LocalDate来定义实体类。\n\n2. 前端传递yyyy-MM-dd hh:mm:ss 格式或yyy-mm-dd格式的字符串即可，系统会自动转换为相应格式\n```\n@Data\npublic class Test{\n    private LocalDateTime date;\n    private LocalDate date2;\n}\n```\n3.  对于数据库而言，LocalDatetime或LocalDate同样会自动转映射，无须关心。\n\n# 2. 响应参数\n对于响应参数而言。\n默认将LocalDatetime类型的属性映射为yyy-MM-dd hh:mm:ss字符串。\n默认将LocalDate类型的属性映射为yyy-MM-dd字符串。\n\n", "s_number": "99", "addtime": "2019-10-15 17:36:56", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "52", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "公参获取", "page_content": "对于一些公用的信息，我们希望快速获取并且无须在每个接口的参数中定义，方便管理与维护。\n\n为此，框架提供了两种获取通用信息的方式。\n\n# 1. 快速使用\n\n## 1.1 注入\n\n```\n\t@Autowired\n\tprivate RequestContext requestContext;\n\tpublic void test(){\n\t\trequestContext.getUserId();\n\t}\n```\n\n## 1.2 静态获取\n\n```\n\tpublic void test(){\n\t\tWebContextFacade.getRequestContext().getUserId();\n\t}\n```\n\n\n# 2. 原理与注意事项\n\n1. 两种方式均使用ThreadLocal，将请求的通用数据放入到当前线程中。在获取时是线程安全的。\n2. 需要注意的是，由于是ThreadLocal，生命周期只存在于当前请求的线程中（controller所在线程）。所以如果希望在其他线程中使用，则需要先在当前线程中获取数据，并传递到其他线程中使用。", "s_number": "99", "addtime": "2019-10-15 17:37:08", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "53", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "定时任务", "page_content": "[TOC]\n\n# 1. 介绍\n\n在微服务的架构下，定时任务一般存在于某个业务项目中，而非向以往项目一样统一在某一项目执行，这样便会出现定时任务分散严重、管理困难。\n对分布式定时任务的解决方案越来越迫切，并且要求存在集中管理、容错、重试、调度、超时、分片、暂停、自动发现节点等众多功能。\nSpring提供的quartz框架已经无法满足我们的需要。\n为此我们引入xxl-job分布式任务调度平台来解决所面临的问题。\n\n# 2. 引入依赖\n\n```\n\tcompile('com.whdx:spring-boot-starter-xxl-job')\n```\n\n# 3. 引入配置\n\n```\nspring:\n  profiles:\n    include: # 引入所需默认配置\n    - xxl-job\napp:\n  xxl-job:\n    admin-address: http://127.0.0.1:8080 #调度中心地址\n\n```\n\n# 4. 创建定时任务执行器\n\n```\n@JobHandler(value = \"demoJobHandler\")\n@Component\npublic class DemoJobHandler extends IJobHandler {\n\n    @Override\n    public ReturnT<String> execute(String param) throws Exception {\n        XxlJobLogger.log(\"Hello World:\" + param);\n        return SUCCESS;\n    }\n}\n```\n\n# 5. 在调度中心新增定时任务策略\n\n默认账号密码：\nadmin\n123456\n\n开发环境调度中心地址：\nhttp://whdx-ms-dev-job-admin.bcbook.cn\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-08-02/5d43a0b1d71bb.png)\n\n其中JobHandler的名字与业务项目中@JobHandler注解内的名称一致。\n\n\n", "s_number": "99", "addtime": "2019-10-15 17:37:21", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "54", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "6", "page_title": "MPush", "page_content": "MPush是基于Netty的开源实时消息推送系统，我们使用实现上课过程中的相关功能。\n\n# 1. 引入\n\n```\ncompile('com.whdx:spring-boot-starter-mpush')\n```\n\n# 2. 配置\n\n以下配置需要根据环境改具体修改。\n\n```\napp:\n  mpush:\n    mp:\n      zk:\n        server-address: zookeeper-dev\n```\n", "s_number": "99", "addtime": "2019-10-15 17:37:44", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "17", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "介绍", "page_content": "十二因素是一种用于构建软件即服务（SAAS）应用程序的方法论，目前被广泛应用于微服务的构建指导：\n\n1. 使用声明性格式进行设置自动化，以最大限度地减少新开发人员加入项目的时间和成本。\n2. 与底层操作系统签订一份干净的合同，在执行环境之间提供最大的可移植性。\n3. 适合在现在云平台上部署，无须服务器和系统管理。\n4. 最大限度地减少开发和生产之间的差异，实现持续部署以实现最大灵活性。\n5. 可以在不对工具、体系结构或开发实践进行重大更改的情况下进行扩展。\n", "s_number": "99", "addtime": "2019-10-15 16:35:24", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "18", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "1.一份代码多份部署", "page_content": "1. 一份基准代码存储在版本控制系统中，多份部署，如git、svn。\n2. 代码库和应用程序之间始终是一对一的关系，如果存在多个代码库，那它将不是一个应用程序，而是一个分布式系统。其中的每个组件都是一个应用程序，每个组件都符合12因素。\n3.  共享相同代码的多个应用违反了12因素，应该使用依赖管理器引入库的形式解决。\n4. 每个应用只有一个代码库，但应用程序的部署将很多，会存在多种版本的部署（多环境、多版本）。", "s_number": "99", "addtime": "2019-10-15 16:35:41", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "19", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "2.显式声明依赖关系", "page_content": "1. 大多数编程语言都提供了一个用于分发支持库的打包系统，如Maven。\n2. 使用依赖清单进行依赖检查，同时使用依赖隔离工具保证应用不会调用系统中存在但是依赖清单中未声明的依赖项。（Maven中的 <dependencyManagement>与 <dependencies>的关系）", "s_number": "99", "addtime": "2019-10-15 16:35:54", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "20", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "3.配置管理", "page_content": "1. 这里的配置指的是与部署环境相关的配置（开发、测试、生产），如数据库、缓存等后端服务的连接配置和位置信息。（url、用户名、密码），不包含应用框架的内部配置，如spring boot的一些配置。\n2. 十二因素要求将配置存在在环境中。典型的方式是存储在环境变量中，这样不会再有机会提交到仓库，也不会与开发语言相关。另一种方式是使用专门的配置服务器进行存储，如spring cloud config。\n3. 配置管理的另一个方面是分组。有时应用会根据特定环境创建不同的配置。随着项目的深入，开发人员也会添加自己的环境配置，这将导致配置组合激增，给管理部署增加了很多不确定因素。环境变量的粒度要足够小，且相对独立，永远不会组合成一个所谓的“环境”，而是独立于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。", "s_number": "99", "addtime": "2019-10-15 17:47:52", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "21", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "4.后端服务作为附加资源", "page_content": "1. 这里的后端服务指的是应用运行所依赖的各种服务，例如数据库、消息代理、缓存系统，以及其他的三方服务。\n2. 12因素应用程序的代码不区分本地和第三方服务。对于应用程序而言，两者都是附加资源，通过url或其他配置进行访问。\n3. 12因素的应用应该在不进行任何代码改动的情况下，将后端服务修改成任意的三方服务，仅仅需要修改配置即可。资源可以随意的附加到部署或者从部署中分离，如果一个应用的数据库异常，应用程序的管理员可以进行修改配置，替换为新的正常数据库。", "s_number": "99", "addtime": "2019-10-15 17:48:09", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "22", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "5.严格分离部署", "page_content": "\n1. 12因素应用程序严格的区分构建、发布和运行阶段\n2. 禁止直接修改运行时的应用或者打补丁，修改后无法再次构建，也不应该在运行时修改配置，而是在发布阶段进行\n3. 每次发布都有一个唯一id，不可修改，形成历史，以便回滚、重新发布。", "s_number": "99", "addtime": "2019-10-15 17:48:20", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "23", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "6.无状态", "page_content": "1. 以一个或多个无状态进程运行。（多个程序负载）\n2. 12因素应用的进程必须是无状态且不共享的，任何需要持久化的数据都要存储在后端服务内。\n3. 一些互联网系统依赖于粘性session，将用户的session数据直接存储在当前内存中，使用路由的手段让用户的请求落在同一个应用上。这个在12因素中是极力反对的，应将session存储在外部缓存中。", "s_number": "99", "addtime": "2019-10-15 17:48:31", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "24", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "7.端口绑定服务", "page_content": "1. 无论是云应用还是微服务模式都要求应用是独立的，而不是依赖外部的应用服务器，这里的端口绑定指的是应用与端口直接进行绑定，而不是通过应用服务器进行端口绑定。极力反对将多个应用放在同一个应用服务器上运行，因为这种模式下，一个应用的异常会对其他应用造成应用，也无法针对单一应用进行横向扩展。如：传统的tomcat+war的形式便是依赖外部应用服务器，SpringBoot便是通过嵌入式应用服务器的形式实现应用与端口进行绑定。\n2. 端口绑定工作应由云平台自动进行，云平台在实现应用到端口的绑定之外，还需要实现内部端口到外部端口的映射和外部端口到域名的映射。（K8s中的service与pod的关系，通过dns与rs组件实现了自动发现与负载，无须关心应用的端口号）\n", "s_number": "99", "addtime": "2019-10-15 17:48:44", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "25", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "8.并发优化", "page_content": "1. 12因素推荐使用进程代替线程来处理并发问题，进程是一等公民。\n2. 之前的系统中，我们会对java程序的jvm参数进行各种调优，当并发增多时，我们增加响应的内存，以保证可以启动更多的线程，来满足更多的并发。这种方式属于纵向扩展。这种方式存在一些问题。首先内存的提高不代表时其他的性能指标提高，往往需要修改应用程序内的代码或其他配置（如启动了一个线程池，内存增加，最大线程数也要增加）。但是如果应用内存在多种类似的扩展，可能会适得其反。\n3. 而12因素推荐使用固定的内存，多个进程来满足更多的并发。即启动多个java程序，相同的内存配置，进行横向扩展。这种方式在十二因素中被称为通过进程模型扩展。\n", "s_number": "99", "addtime": "2019-10-15 17:48:57", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "26", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "9.可随时丢弃", "page_content": "1. 通过快速启动和正常关闭最大限度的提高稳定性\n2. 这个原则要求应用可以瞬间的启动和停止，因为这将有利于应用快速进行横向扩展或故障后的重新部署，都是健壮性的体现。对于web进程（可以理解为短任务），收到停止请求后，应当允许当前请求完成。对于工作进程（长任务），需要将当前任务返回到队列来实现正常关闭，以便下次启动时可以继续执行当前任务。如kafka中，消息在处理过程中进行了关闭，此时还没有返回ack，则在下次启动后仍然会继续处理任务。\n3. 应用还必须应对突入起来的退出，在硬件出现故障时或进程崩溃时，应用需要保证不会对其使用的数据造成损坏，遵循无状态的原则、将数据交由后端服务处理的应用可以很容易的将应对突然退出的复杂度，并将其外部化（像前文说的kafka本身基于磁盘的读写，并且又存在ack应答机制）。", "s_number": "99", "addtime": "2019-10-15 17:49:26", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "27", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "10.环境等价", "page_content": "1. 保持开发、测试、生产尽可能的相似\n2. 十二因素旨在通过缩小开发和生产之间的差距来进行持续部署。缩短时间差、减少人员差距、缩小工具差距。\n\n时间差：开发人员可以编写代码并在几小时甚至几分钟后部署代码（ci/cd）\n人员差距：编写代码的开发人员密切参与部署和观察其生产行为（devops）\n缩小工具差距：尽可能保持开发和生产（docker）\nps: kubernetes已经解决了上述问题。使运维人员仅关心硬件环境而无须关心软件内部的参数配置，开发人员关心软件及参数配置而无须修改复杂的机器配置。", "s_number": "99", "addtime": "2019-10-15 17:50:50", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "28", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "11.日志管理", "page_content": "1. 将日志视为事件流，日志提供对正在运行的应用程序行为的可见性。在基于服务器的环境中，它们通常写入磁盘上的文件，但是这只是一种输出格式。\n2. 十二因素应用程序不关心日志的输出或存储。换句话说，十二因素不希望应用程序管理自己的日志文件。以前我们习惯将应用程序产生的日志分类输出到不同的文件，并且为了避免日志过大，会配置清除策略。十二因素极力反对上述做法。\n3. 十二因素要求应用程序将日志以流的方式进行标准输出和标准错误输出，然后由运行环境捕捉，转发到专门的日志处理服务进行处理。常见的实现方案为：spring boot将日志写入到kafka中，logstash监听kafka进行拉取日志，写入到elasticsearch中进行统一管理，kibana可以操作es进行分类检索。\n", "s_number": "99", "addtime": "2019-10-15 17:56:30", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "29", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "3", "page_title": "12.任务的管理", "page_content": "1. 开发人员通常希望为应用程序执行一次性维护或管理的任务（如数据库的升级脚本）。12因素要求一次性维护/管理的任务应该与应用程序常规长期运行进程的环境相同。它们针对一个版本运行，使用与该版本运行的任何进程相同的代码库和配置。\n2. 如果任务是修改应用配置，应该使用配置管理服务进行操作（环境变量、configMap、cloud config）。如果是批处理任务，如数据的迁移、清洗或者检查，则使用云平台的批处理机制进行操作。", "s_number": "99", "addtime": "2019-10-15 17:56:41", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "55", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "Java编码注意事项", "page_content": "#### 1. 接口请求参数超过1个必须建立bean来接收参数。响应参数必须建立Bean。\n#### 2. 不允许使用Map处理业务，包含但不限于接口、数据库、缓存。请建立专有bean。\n#### 3. 尽早抛出异常/返回结果，不要使用大量嵌套if else。\n反例：\n\n```\nif(type!=1){\n\tlist = findByDb();\n\tif(list!=null){\n\t\tdosomething...\n\t}else{\n\t\treturn;\n\t}\n}else{\n\treturn;\n}\n```\n\n正例：\n\n```\nif(type == 1){\n\treturn;\n}\nlist = findByDb();\nif(list==null){\n\treturn;\n}\ndosomething...\n```\n\n#### 4. 如果参数中涉及到日期，请求参数在接口文档定义时请使用timestamp或指定格式的字符串，而不要让前端直接使用其开发语言创建日期的方式。", "s_number": "99", "addtime": "2019-10-15 17:38:22", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "56", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "Mysql使用规范", "page_content": "#### 1. 在对数据库进行操作时，请尽量进行单表操作，将逻辑放入java中编写，而非使用关联查询，子查询等消耗性能的方式进行，同样可方便日后的项目重构，并且增加代码可读性。\n#### 2. 针对数据库实体建立service、mapper，并且尽量使用BaseMapper、ServiceImpl所提供的方法做单表的操作。\n#### 3. 对数据库的like查询，希望您使用右侧模糊策略：\"like%\"。（请了解B-TREE最左前缀索引匹配原则）\n#### 4. 索引名称，普通索引“idx\\_{字段名称}\\_{字段名称}”，唯一索引以udx开头。\n#### 5. 对于数据行多的表进行排序时，需要建立索引，并且与where条件相组合。如where a=1 order by b，此时我们需要建立组合索引idx_a_b\n#### 6. 根据业务适当冗余字段以提高查询性能。\n#### 7. 创建索引时避免有如下极端误解:\n\n误认为一个查询就需要建一个索引。\n误认为索引会消耗空间、严重拖慢更新和新增速度。\n误认为唯一索引一律需要在应用层通过“先查后插”方式解决。\n\n#### 8. 不要使用 count(列名) 来替代 count()，当该列为null时，不会被统计到。\n#### 9. 不要使用物理外键。\n#### 10. in操作需要在1000以内。\n#### 11. utf8mb4存储表情。\n#### 12. Collation用于控制排序规则及字符串比对方式，以\\_ci结尾的，是不区分大小写的，如果业务需要区分大小写，请使用\\_bin结尾。\n#### 13. 数据库字段使用下划线进行分割，一旦进入业务，必须使用驼峰进行处理。\n", "s_number": "99", "addtime": "2019-10-15 17:38:37", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "57", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "异常规范", "page_content": "#### 1. 对于异常来说，框架已经进行了全局拦截。无须手动拦截。\n#### 2. 当我们处理列表，并且操作数据时，如果我们希望列表中某一项处理失败不影响整个列表的结果，我们可以将处理逻辑抽离出方法，并且在方法上增加事务。伪代码如下：\n\n```\nfor(item:List){\n\tprocess(item)\n}\n\n@Transactional\nprivate void process(item){\n\tdo something...\n}\n\n```", "s_number": "99", "addtime": "2019-10-15 17:38:49", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "58", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "Redis使用规范", "page_content": "欢迎使用ShowDoc！", "s_number": "99", "addtime": "2019-10-15 16:31:00", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "59", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "Mongo使用规范", "page_content": "欢迎使用ShowDoc！", "s_number": "99", "addtime": "2019-10-15 16:31:06", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "60", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "7", "page_title": "分包规范", "page_content": "[TOC]\n\n# 1. 规范\n\n```\n--com.whdx.业务名称\n----apiservice\n----子模块1\n--------common\n------------po\n----------------XXX.java\n------------utils\n------------provider\n----------------BusinessController.java\n--------teacher\n------------controller\n----------------PcController.java\n----------------AppController.java\n----------------PadController.java\n------------service\n------------dao\n----------------mapper\n--------------------XXXMapper.xml\n----------------XXXMapper.java\n------------dto\n----------------XXXReq.java\n----------------XXXRes.java\n------------listener\n------------job\n------------constant\n--------student\n----子模块2\n\n```\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-25/5d38ffcae57f0.png)\n\n\n- apiservice: 该项目中，调用其他项目所需的服务定义\n- 子模块：由具体业务的名称决定该包名\n- teacher: 教师端\n- student: 学生端\n- common: 多端共用，一般包含持久化实体po、拦截器、配置、utils等。\n- provider: 为其他项目提供的内部访问接口，不对外暴露，其中的Controller名称根据具体情况而定\n- controller: 主要包含对外暴露的接口，根据终端又分为多个Controller，如PcController、AppController，我们希望数据转换及检验在这一步进行，当然共性的转换会放入拦截器中。\n- service: 服务层，负责操作数据库操作层与处理业务逻辑，复杂业务可根据情况而定拆分出Mananager层来组合多个service\n- dao: 数据库操作层，与数据库交互，基本的增删改查，请不要将业务逻辑冗余在sql中\n- dto: 数据传输、转换，请求与返回实体需分别建立。\n- listener: 消息监听者，监听消息系统消息，以便做出处理。\n- job: 定时任务，针对该模块的定时任务。\n- constant: 针对有该模块的常量，如放入redis中的key。\n\n\n\n# 2. 思路\n\n基本思路如下\n![](http://129.28.201.138:24999/Public/Uploads/2019-07-10/5d259e835e20a.png)\n\n\n- 某个业务首先为使用角色区分建立不同的访问通道，不同角色访问的数据在大多数情况是不同的。即“包”。\n- 角色访问通道下，为不同终端建立相应的访问通道，以便转换、组合相应终端所提交、所需要的数据。即“controller”。\n- 终端通道最终调用针对相同某个业务实体所建立的服务类，即“service”。\n\n# 3. 对于mongo、elasticsearch的操作\n\n在使用mongo、elasticsearch这些nosql数据库前，我们使用的是mysql这样的数据库来存储持久化数据。而此时我们一般会建立相应的包，里面存在po、mapper、service，来供其他人调用。\n相应地，nosql数据库同样需要这样建立，我们需要抽象出某个或某组行为相同的实体创建业务模块，并且提供po、service、dao（repository）来对外暴露服务，供相同服务下共同调用。", "s_number": "99", "addtime": "2019-10-15 17:39:30", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "61", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "8", "page_title": "介绍", "page_content": "[TOC]\n# 1. 背景\n在前后端分离的开发模式下，我们时常面临着以下几个问题：\n\n1. 盗链。\n2. 如何判断请求用户是否合法。\n3. 如何防止请求参数篡改。\n4. 服务端如何快速获取公共参数，而无须在每个接口中均携带。\n\n为了解决以上问题，我们需要一个统一、安全的接口规范。\n\n# 2. 认证与授权\n\n认证（authentication ）与授权（authorization ）往往是容易混淆的两个概念，当我们的系统涉及到登录、权限控制时，这两个概念通常会相互结合使用。一般来说认证与授权会作为系统基础架构的关键部分。\n\n\n## 2.1 认证\n\n认证是通过某种凭据来验证身份是否正确，如用户名和密码。\n\n## 2.2 授权\n\n授权是在系统成功验证身份后发生的，服务端会将认证通过的用户颁发一个访问系统的凭据，用户访问系统时携带其凭据，服务端通过它来确定已经通过认证的用户可以访问哪些资源，即权限控制。\n\n比如我们后台管理在登录成功后根据角色不同，展示不同的菜单。移动端根据角色不同使用不同的终端（教师端、 学生端）。PC端登录不同的账号展示不同的功能。需要注意的是，页面展示与接口请求通常是共同完成权限控制的。\n\n\n# 3. RBAC\n\n谈到认证授权，我们就不得不提起RBAC（Role-Based Access Control）模型，它是一种基于角色的访问控制。包含三个概念，用户、角色、权限，用户通过成为适当的角色成员而得到某些权限。\n\nRBAC往往通过建立数据表来动态控制用户、角色、权限三者之间的关系。\n\n一般模型如下：\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-09-17/5d8038b933ceb.png)\n\n基本流程如下：\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-09-17/5d8038bd89e2b.png)\n\n流程中的每一步都可以进行扩展，比如：\n1. 登录的认证可以扩展为三方登录。\n2. 服务端返回凭证的同时，可以返回该凭证的权限列表，实现前端动态生成菜单的功能。\n3. 前端请求接口携带的凭证，可以存储在session、cookie、或header中。客户端可以主动传输或被动传输。\n4. 服务端通过凭证进行权限检验时，可以将权限列表放入缓存中，\n\n# 4. JWT\n在RBAC中生成的凭据，既可以有状态的存储在服务端，也可以无状态的加密后返还给客户端。\n\nJWT是一种无状态的加密凭据，它的设计紧凑并且安全。\n\nJWT的全称是Json web token。它一般被用来在客户端和服务端之间传递认证信息。简单来说，它就是一个token。但是它可以被加密和解密。\n\nJWT是由三段信息构成的。\n\n\n第一部分我们称它为头部（header),第二部分我们称其为有效载荷（payload)，即货物，要传输的业务信息，第三部分是签证（signature).\n\n\n在业务场景中，我们只需要关心Payload部分即可。一般情况我们会将Payload中放入与系统用户相关的信息，如：\n\n```\n{\n\t\"id\":\"用户id\",\n\t\"roleId\":\"角色id\"\n}\n```\n\n将这三段信息文本用“.”链接一起就构成了Jwt字符串：\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n```\n", "s_number": "99", "addtime": "2019-10-15 17:42:40", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "62", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "8", "page_title": "前端接口权限设计", "page_content": "[TOC]\n\n# 1. 基本组成\n我们将所有涉及到接口检验的信息均放在header中，以保证与业务参数的分离。（注意，Cookie也属于Header）\n包含如下几部分：\n\n1. Auth-Token：检验用户有效性。\n2. Common-Param：存放公共参数。\n3. Sign：参数签名，检验请求的有效性。\n4. Cookie: 将上述三个参数放入\n\n示例：\n\n```\nAuth-Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\nCommon-Param: {\"timestamp\":\"请求时间戳，格式为13位时间戳格式，如1564456294337\",\"clientType\":\"客户端类型（具体需要讨论）\",\"uuid\":\"设备id\",\"clientVersion\":\"客户端版本\",\"systemVersion\":\"系统版本号\",\"model\":\"设备型号\",\"manufacturer\":\"生产商\",\"userId\":\"用户id\",\"roleType\":\"角色类型（学生 老师）\"}\n\nSign: F6909B71ECDBE2ED610CEB139EB02D41\n\nCookie: Auth-Token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c;Common-Param={\"timestamp\":\"请求时间戳，格式为13位时间戳格式，如1564456294337\",\"clientType\":\"客户端类型（具体需要讨论）\",\"uuid\":\"设备id\",\"clientVersion\":\"客户端版本\",\"systemVersion\":\"系统版本号\",\"model\":\"设备型号\",\"manufacturer\":\"生产商\",\"userId\":\"用户id\",\"roleType\":\"角色类型（学生 老师）\"};Sign=F6909B71ECDBE2ED610CEB139EB02D41;\n```\n\n\n## 1.1 Auth-Token\n1. Auth-Token主要用来检验用户的合法性。我们需要在header及cookie中增加该参数。\n2. Auth-Token内容格式为JWT，由服务端返回。\n3. Auth-Token存在有效期（有效期为7天），当即将超出有效期后（不足一天），服务端会在客户端请求接口时静默重新授权，并返回给客户端新的token，客户端覆盖本地token即可。\n4. 如超出有效期后客户端一段时间内并未请求接口。则再次请求时，服务端将会返回认证失败状态码，客户端跳转至登录页即可。\n5. Auth-Token与用户的关系会存储在缓存中，满足业务需要，如一个用户只允许登录一台设备。\n6. 生成新token后需要返回给前端使用，我们将新token放入header中返回给前端，header的key为： Auth-Token。值为：jwt。前端在responseHeader中可以拿到该值。\n\n## 1.2 Common-Param\n1. Common-Param主要用来存放接口请求的公共参数。\n2. Common-Param内容为AES加密字符串，将多个公共参数序列化为json后进行AES加密。\n3. 后端拿到公参后需对公参进行相应的解密。\n\n\nCommon-Param字段不限于以下字段，需要具体商定：\n\n```\n{\n\t\"timestamp\":\"请求时间戳，格式为13位时间戳格式，如1564456294337\",\n\t\"clientType\":\"客户端类型（具体需要讨论）\",\n\t\"uuid\":\"设备id\",\n\t\"clientVersion\":\"客户端版本\",\n\t\"systemVersion\":\"系统版本号\",\n\t\"model\":\"设备型号\",\n\t\"manufacturer\":\"生产商\",\n\t\"userId\":\"用户id\",\n\t\"roleType\":\"角色类型（学生 老师）\"\n}\n```\n\n\n\n## 1.3 sign\n1. sign为参数签名，用于检验参数是否被篡改。\n2. sign的内容为32位小写MD5签名后的字符串，并将其放入header及cookie中。\n3. 由于http请求方式众多，目前我们对url路径、url参数及request body进行检验。\n4. url路径直接拼接。\n5. url参数加密时，需要将其所有参数名按照字典排序后，拼接参数值与参数名后加入header中的timestamp进行md5。\n6. 对于request body，我们需要将body体中的json数据与timestamp、secret_key进行拼接后md5即可。\n7. secret_key为服务端设定，客户端存储在本地。\n8. 加密参数拼接顺序为：路径>参数>body>时间戳>secret_key\n\n\n### 1.3.1 URL参数请求加密示例\n\n假设一个请求如下：\n\nhttp://test.cn/info?b=1&a=2&d=3&c=5\n\nbody体如下：\n\n```\n{\"a\":\"1\"}\n```\n\n则拼接url路径如下：\n\n```\n/info\n```\n\n则按照字典排序参数后如下：\n\na=2&b=1&c=5&d=3\n\n\n\n拼接参数名与值后如下：\n\n```\n/infoa2b1c5d3\n```\n\n拼接body体后如下：\n\n```\n/infoa2b1c5d3{\"a\":\"1\"}\n```\n\n加入timestamp如下：\n\n\n\n```\n/infoa2b1c5d3{\"a\":\"1\"}1564456294337\n```\n\n加入secret_key如下（假设为123）：\n\n```\n/infoa2b1c5d3{\"a\":\"1\"}1564456294337123\n```\n\nmd5后如下：\n\n```\n5522a63113458ad14b15c3cd054feacf\n```\n\n\n最后将md5后的值放入sign中", "s_number": "99", "addtime": "2019-10-15 17:42:54", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "63", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "8", "page_title": "Auth模块实现思路", "page_content": "[TOC]\n\n# 模块名称\n\nwhdx-auth\nspring-boot-starter-auth\n\n# 基本流程图\n\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-10-08/5d9bfe7959ac1.png)\n\n# 实现思路\n\n分为两大功能：token生成、token验证\n\n## token生成\n\n1. 使用jwt算法进行token生成，需要用户id、密钥、环境、过期时间几个重要参数。\n2. 本模块仅仅对外暴露jwt生成接口，不验证用户账号密码是否正确。\n3. jwt过期时间设置为7天。\n4. jwt生成后需存储至redis中，时间为7天，key：auth-token-{用户id}，value：jwt。jwt本身为无状态，正常不需要持久化，但此处我们希望一个账号仅在一个设备中登录，故需要存储至redis中。\n\n\n## token验证\n\n1. 前端传递的token会存储在header或cookie中，优先header验证，其次cookie验证。\n2. 通过前端传递过的token，进行jwt解密，解密后获取到用户id。如果解析失败，返回登录状态过期。\n3. 通过用户id获取存储在redis中的旧token，旧token在刷新token时生成（第六步）。判断当前token是否与旧token一致，如果一致放行，以下流程均不执行。不一致不做任何处理，继续以下流程。\n4. 通过用户id获取到redis中的token，判断与前端传递的token是否一致。如果不一致，返回登录状态过期。\n5. 判断当前jwt，过期时间是否即将超期。即将：不足1天。此处时间不是获取redis，而是获取jwt中的。\n6. 如果即将超期，则生成新的token，需并且刷新redis中的token。在生成新token同时，需要将旧token也存储进redis中，保证并发情况下的使用。旧token存储方式为，key：auth-token-{用户id}-last  value：jwt。旧token在redis中的时效：30秒。\n7. 生成新token放入redis中后，新token需要返回给前端，我们将新token放入header中返回给前端，header的key为： Auth-Token。值为：jwt。前端取到后存储到本地。", "s_number": "99", "addtime": "2019-10-15 17:43:06", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "64", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "9", "page_title": "介绍", "page_content": "#  背景\n\n1. 为了实现线上两个版本并存，一批用户使用正式版（即旧版），另一批用户使用灰度版本（又称金丝雀版本），优先体验新版特性。\n2. 保证两个版本可以任意切换与废弃，当灰度期结束后，正式版本全面替换为灰度版本后，正在使用的灰度版本无须升级即可自动切换为正式版本。\n3. 不仅仅需要支持接口灰度，还需要支撑手机端内嵌的h5页面灰度（PC站灰度可以直接通过域名形式部署多套环境）\n\n\n", "s_number": "99", "addtime": "2019-10-15 17:43:25", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


{"page_id": "65", "author_uid": "1", "author_username": "showdoc", "item_id": "1", "cat_id": "9", "page_title": "方案说明", "page_content": "[TOC]\n\n# 1. 基本流程说明\n\n![](http://129.28.201.138:24999/Public/Uploads/2019-09-19/5d82e635c7091.png)\n\n1. 新增版本转发Nginx服务器与灰度版本服务器，\n2. 版本转发服务，通过lua脚本进行判断请求方是否需要转入灰度服务。灰度版本号写死在脚本中。\n3. 灰度服务器中存在的服务自成一套系统，可以单独运行（即复制现有部署结构）。灰度服务与正式服务的数据库相同。\n\n## 1.1 接口请求流程\n\n1. Pad端/手机端请求接口时，在每个接口请求时都携带公共参数：客户端版本号\n2. Nginx接收到请求后，通过lua脚本获取header请求头中的版本号，并与灰度版本号进行比对，判断当前是否为灰度请求，并转发到相应版本的接口集群中。\n\n## 1.2 H5页面请求流程\n\n1. Pad端/手机端通过WebView打开H5页面前，将当前客户端版本号等公共信息设置进WebView的cookie中，其中domain为当前要请求的页面的域名。\n2. Nginx接收到请求后，通过lua脚本获取Cookie请求头中的版本号，并与灰度版本号进行比对，判断当前是否为灰度请求，并转发到相应版本的网页集群中。\n\n## 1.3 Header及Cookie规范\n\n同[接口规范](http://showdoc.bcbook.cn:4999/web/#/9?page_id=348)中的Common-Param与Cookie设置。\nHeader示例如下：\n\n```\nCommon-Param: {\"timestamp\":\"请求时间戳，格式为13位时间戳格式，如1564456294337\",\"clientType\":\"客户端类型（具体需要讨论）\",\"uuid\":\"设备id\",\"clientVersion\":\"客户端版本\",\"systemVersion\":\"系统版本号\",\"model\":\"设备型号\",\"manufacturer\":\"生产商\",\"userId\":\"用户id\",\"roleType\":\"角色类型（学生 老师）\"}\n```\n\nCookie示例如下：\n\n```\nCookie: Common-Param={\"timestamp\":\"请求时间戳，格式为13位时间戳格式，如1564456294337\",\"clientType\":\"客户端类型（具体需要讨论）\",\"uuid\":\"设备id\",\"clientVersion\":\"客户端版本\",\"systemVersion\":\"系统版本号\",\"model\":\"设备型号\",\"manufacturer\":\"生产商\",\"userId\":\"用户id\",\"roleType\":\"角色类型（学生 老师）\"};\n```", "s_number": "99", "addtime": "2019-10-15 17:43:38", "page_comments": "", "is_del": "0", "attachment_count": "0", "unique_key": ""}


